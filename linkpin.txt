================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2024-11-21T17:23:39.008742

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
assets/
  locales/
    zh_CN/
      messages.json
  icon.png
src/
  auth/
    components/
      AuthCallback.tsx
      GithubAuthButton.tsx
      UserProfile.tsx
    providers/
      base.ts
      github.ts
    services/
      supabase/
        client.ts
        config.ts
        index.ts
        types.ts
    stores/
      auth.ts
    types/
      index.ts
    index.ts
  background/
    index.ts
  components/
    bookmark/
      buttons/
        DeleteButton.tsx
        EditButton.tsx
        PinButton.tsx
      BookmarkIcon.tsx
      BookmarkItem.tsx
      BookmarkList.tsx
    folder/
      CreateFolderDrawer.tsx
    settings/
      GithubBackupSection.tsx
    tag/
      form/
        ActionButtons.tsx
        InputArea.tsx
        KeywordInput.tsx
        MessageList.tsx
        TagForm.tsx
        TagFormLayout.tsx
        TagTemplatePreview.tsx
        TagTemplates.tsx
      TagList.tsx
    ui/
      button.tsx
      card.tsx
      dialog.tsx
      drawer.tsx
      hint-dialog.tsx
      input.tsx
      label.tsx
      loading.tsx
      progress.tsx
      select.tsx
      toast.tsx
      toaster.tsx
      tooltip.tsx
    views/
      AllView.tsx
      BaseView.tsx
      HotView.tsx
      PinView.tsx
      RecentView.tsx
      TagView.tsx
    BottomNav.tsx
    CommandList.tsx
    SearchBar.tsx
    SettingsButton.tsx
    SettingsView.tsx
    ThemeToggle.tsx
    ViewHeader.tsx
  config/
    bookmark.ts
    tabs.ts
    tagTemplates.ts
  contexts/
    CommandContext.tsx
    PinnedContext.tsx
    SearchContext.tsx
    TabContext.tsx
    ThemeContext.tsx
  hooks/
    use-toast.ts
    useDebounce.ts
    useTagForm.ts
  lib/
    events.ts
    utils.ts
  services/
    bookmarks/
      base.ts
      index.ts
      keyword.ts
      pin.ts
      search.ts
      tag.ts
      template.ts
    storage/
      base.ts
      description.ts
      hint.ts
      index.ts
      pin.ts
      settings.ts
      tag.ts
      theme.ts
      visit.ts
    icons.ts
  sidepanel/
    index.tsx
  styles/
    globals.css
  tabs/
    auth-callback.tsx
  types/
    bookmark.ts
    command.ts
    settings.ts
    tab.ts
    tag.ts
.prettierrc.mjs
README.md
components.json
package.json
postcss.config.js
tailwind.config.js
tsconfig.json

================================================================
Repository Files
================================================================

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './src/**/*.{ts,tsx}',
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        "red-primary": "hsl(var(--red-primary))",
        "red-secondary": "hsl(var(--red-secondary))",
        "orange-primary": "hsl(var(--orange-primary))",
        "orange-secondary": "hsl(var(--orange-secondary))",
        "yellow-primary": "hsl(var(--yellow-primary))",
        "yellow-secondary": "hsl(var(--yellow-secondary))",
        "green-primary": "hsl(var(--green-primary))",
        "green-secondary": "hsl(var(--green-secondary))",
        "cyan-primary": "hsl(var(--cyan-primary))",
        "cyan-secondary": "hsl(var(--cyan-secondary))",
        "blue-primary": "hsl(var(--blue-primary))",
        "blue-secondary": "hsl(var(--blue-secondary))",
        "purple-primary": "hsl(var(--purple-primary))",
        "purple-secondary": "hsl(var(--purple-secondary))",
        "magenta-primary": "hsl(var(--magenta-primary))",
        "magenta-secondary": "hsl(var(--magenta-secondary))",
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        "command-show": {
          from: { opacity: 0, transform: "scale(0.98)" },
          to: { opacity: 1, transform: "scale(1)" },
        },
        "command-hide": {
          from: { opacity: 1, transform: "scale(1)" },
          to: { opacity: 0, transform: "scale(0.98)" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "command-show": "command-show 0.1s ease-in-out",
        "command-hide": "command-hide 0.1s ease-in-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}

================
File: README.md
================
This is a [Plasmo extension](https://docs.plasmo.com/) project bootstrapped with [`plasmo init`](https://www.npmjs.com/package/plasmo).

## Getting Started

First, run the development server:

```bash
pnpm dev
# or
npm run dev
```

Open your browser and load the appropriate development build. For example, if you are developing for the chrome browser, using manifest v3, use: `build/chrome-mv3-dev`.

You can start editing the popup by modifying `popup.tsx`. It should auto-update as you make changes. To add an options page, simply add a `options.tsx` file to the root of the project, with a react component default exported. Likewise to add a content page, add a `content.ts` file to the root of the project, importing some module and do some logic, then reload the extension on your browser.

For further guidance, [visit our Documentation](https://docs.plasmo.com/)

## Making production build

Run the following:

```bash
pnpm build
# or
npm run build
```

This should create a production bundle for your extension, ready to be zipped and published to the stores.

```
pnpm build --zip
```

### Doc

```text
repopack /Users/yangzie/www/browser/Linkit -c /Users/yangzie/www/browser/Linkit/repopack.json -o Linkit.txt -i "*.log,.github,*.txt,repopack.json"
```

```bash
# add 
pnpm dlx shadcn@latest add input
```

### Auth

```bash



chrome-extension://dapdkkpahggjaaocdaahppgfflpbhoia/tabs/auth-callback.html
```

================
File: package.json
================
{
  "name": "Linkit",
  "displayName": "__MSG_extensionName__",
  "version": "0.0.1",
  "description": "__MSG_extensionDescription__",
  "author": "lnmput@gmail.com",
  "scripts": {
    "dev": "plasmo dev",
    "build": "plasmo build",
    "package": "plasmo package"
  },
  "dependencies": {
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@supabase/supabase-js": "^2.46.1",
    "add": "^2.0.6",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "framer-motion": "^11.11.15",
    "lucide-react": "^0.454.0",
    "plasmo": "0.89.4",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-hook-form": "^7.53.2",
    "react-hot-toast": "^2.4.1",
    "react-router-dom": "^6.28.0",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^1.1.1",
    "zustand": "^5.0.1"
  },
  "devDependencies": {
    "@ianvs/prettier-plugin-sort-imports": "4.1.1",
    "@types/chrome": "0.0.258",
    "@types/node": "20.11.5",
    "@types/react": "18.2.48",
    "@types/react-dom": "18.2.18",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.47",
    "prettier": "3.2.4",
    "tailwindcss": "^3.4.14",
    "typescript": "5.3.3"
  },
  "manifest": {
    "default_locale": "zh_CN",
    "name": "__MSG_extensionName__",
    "host_permissions": [
      "https://*.supabase.co/*",
      "https://github.com/*"
    ],
    "permissions": [
      "sidePanel",
      "tabs",
      "bookmarks",
      "storage",
      "commands",
      "identity"
    ],
    "side_panel": {
      "default_path": "sidepanel.html"
    },
    "key": "$CRX_KEY",
    "web_accessible_resources": [
      {
        "resources": [
          "sidepanel.html"
        ],
        "matches": [
          "<all_urls>"
        ],
        "extension_ids": [
          "$CRX_ID"
        ]
      }
    ],
    "commands": {
      "_execute_action": {
        "suggested_key": {
          "default": "Alt+B",
          "mac": "Command+B"
        },
        "description": "打开书签侧边栏"
      },
      "_focus_search": {
        "suggested_key": {
          "default": "Ctrl+K",
          "mac": "Command+K"
        },
        "description": "聚焦到搜索框"
      }
    },
    "content_security_policy": {
      "extension_pages": "script-src 'self'; object-src 'self'; frame-ancestors 'none';"
    }
  }
}

================
File: components.json
================
{
    "$schema": "https://ui.shadcn.com/schema.json",
    "style": "default",
    "rsc": false,
    "tsx": true,
    "tailwind": {
      "config": "tailwind.config.js",
      "css": "src/styles/globals.css",
      "baseColor": "slate",
      "cssVariables": true
    },
    "aliases": {
      "components": "~/components",
      "utils": "~/lib/utils"
    }
  }

================
File: tsconfig.json
================
{
  "extends": "plasmo/templates/tsconfig.base",
  "exclude": ["node_modules"],
  "include": [
    ".plasmo/index.d.ts",
     "./**/*.ts", 
     "./**/*.tsx"
  ],
  "compilerOptions": {
    "paths": {
      "~/*": ["./src/*"]
    },
    "baseUrl": "."
  }
}

================
File: .prettierrc.mjs
================
/**
 * @type {import('prettier').Options}
 */
export default {
  printWidth: 80,
  tabWidth: 2,
  useTabs: false,
  semi: false,
  singleQuote: false,
  trailingComma: "none",
  bracketSpacing: true,
  bracketSameLine: true,
  plugins: ["@ianvs/prettier-plugin-sort-imports"],
  importOrder: [
    "<BUILTIN_MODULES>", // Node.js built-in modules
    "<THIRD_PARTY_MODULES>", // Imports not matched by other special words or groups.
    "", // Empty line
    "^@plasmo/(.*)$",
    "",
    "^@plasmohq/(.*)$",
    "",
    "^~(.*)$",
    "",
    "^[./]"
  ]
}

================
File: postcss.config.js
================
/**
 * @type {import('postcss').ProcessOptions}
 */
module.exports = {
    plugins: {
      tailwindcss: {},
      autoprefixer: {}
    }
}

================
File: assets/locales/zh_CN/messages.json
================
{
  "extensionName": {
    "message": "书签管理",
    "description": "扩展名称"
  },
  "extensionDescription": {
    "message": "轻松管理你的书签",
    "description": "扩展描述"
  },
  "extensionTitle": {
    "message": "书签管理",
    "description": "扩展标题"
  },
  "extensionSubTitle": {
    "message": "轻松管理你的书签",
    "description": "扩展副标题"
  },
  "settings": {
    "message": "设置",
    "description": "设置文字"
  },
  "settings_title": {
    "message": "默认标签页面",
    "description": "默认标签页面文字"
  },
  "settings_description": {
    "message": "选择打开扩展时默认显示的标签页面",
    "description": "默认标签页面描述"
  },
  "settings_close": {
    "message": "关闭",
    "description": "关闭文字"
  },
  "bookmarkFolderOthers": {
    "message": "其他书签",
    "description": "其他书签文字"
  },
  "bookmarkFolderMobile": {
    "message": "移动书签",
    "description": "移动书签文字"
  } 
}

================
File: src/background/index.ts
================
export {}

// src/background/index.ts

// 初始化设置 sidepanel 行为
chrome.sidePanel.setPanelBehavior({ openPanelOnActionClick: true }).catch((error) => {
  console.error("Error setting panel behavior:", error)
})

// 监听快捷键命令
chrome.commands.onCommand.addListener((command) => {
  if (command === "_execute_action") {
    // 切换 sidepanel 的显示状态
    chrome.sidePanel.toggle().catch((error) => {
      console.error("Error toggling side panel:", error)
    })
  } else if (command === "_focus_search") {
    // 向 sidepanel 发送消息
    chrome.runtime.sendMessage({ type: "FOCUS_SEARCH" })
  }
})

// 清理任何之前的状态
chrome.runtime.onInstalled.addListener(() => {
  console.log("Extension installed/updated")
})

================
File: src/tabs/auth-callback.tsx
================
function AuthCallback() {
    return (
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          padding: 16
        }}>
        <h2>Auth Callback</h2>

      </div>
    )
  }
   
  export default AuthCallback

================
File: src/types/tag.ts
================
import type { LucideIcon } from "lucide-react"

// src/types/tag.ts
export interface Tag {
  id: string
  name: string
  conditions: {
    urlKeywords?: string[]
    titleKeywords?: string[]
    dateRange?: {
      start?: Date
      end?: Date
    }
  }
  createdAt: number
  updatedAt: number
  version: number
}

export interface TagStorage {
  version: number
  tags: Tag[]
}

export interface TagTemplate {
  id: string
  name: string
  description?: string
  icon?: LucideIcon
  conditions: {
    urlKeywords: string[]
    titleKeywords: string[]
  }
  weight?: number
}

interface Message {
  type: 'user' | 'assistant'
  content: string
  hint?: string
  warning?: boolean
}

================
File: src/types/tab.ts
================
// src/types/tab.ts
export type TabType = "all" | "hot" | "recent" | "pinned" | "tag"

================
File: src/types/settings.ts
================
// src/types/settings.ts
export interface Settings {
  defaultTab: "all" | "recent" | "pinned" | "tag"
}

export const DEFAULT_SETTINGS: Settings = {
  defaultTab: "all"
}

================
File: src/types/bookmark.ts
================
// src/types/bookmark.ts
export interface BookmarkTreeNode {
  id: string
  parentId?: string
  index?: number
  url?: string
  title: string
  dateAdded?: number
  dateGroupModified?: number
  children?: BookmarkTreeNode[]
}

export interface BookmarkItemProps {
  bookmark: BookmarkTreeNode
  level?: number
  className?: string
}

================
File: src/types/command.ts
================
import type { LucideIcon } from "lucide-react"

// src/types/command.ts
export interface Command {
    id: string
    label: string
    icon?: LucideIcon
    shortcut?: string
    action: () => Promise<void>
}

================
File: src/contexts/SearchContext.tsx
================
// src/contexts/SearchContext.tsx
import React, { createContext, useContext, useState, useCallback } from 'react'
import type { BookmarkTreeNode } from '~/types/bookmark'
import { searchService } from '~/services/bookmarks'

interface SearchContextType {
  searchTerm: string
  isSearching: boolean
  searchResults: BookmarkTreeNode[]
  error: string | null
  inputValue: string
  setInputValue: (value: string) => void
  search: (term: string) => Promise<void>
  clearSearch: () => void
}

const SearchContext = createContext<SearchContextType | null>(null)

export function SearchProvider({ children }: { children: React.ReactNode }) {
  const [searchTerm, setSearchTerm] = useState("")
  const [inputValue, setInputValue] = useState("")
  const [isSearching, setIsSearching] = useState(false)
  const [searchResults, setSearchResults] = useState<BookmarkTreeNode[]>([])
  const [error, setError] = useState<string | null>(null)

  const search = useCallback(async (term: string) => {
    const trimmedTerm = term.trim()
    setSearchTerm(trimmedTerm)
    
    if (!trimmedTerm) {
      clearSearch()
      return
    }

    try {
      setIsSearching(true)
      setError(null)
      const results = await searchService.search(trimmedTerm)
      setSearchResults(results)
    } catch (err) {
      console.error('Search error:', err)
      setError('搜索失败，请重试')
      setSearchResults([])
    } finally {
      setIsSearching(false)
    }
  }, [])

  const clearSearch = useCallback(() => {
    setSearchTerm("")
    setInputValue("")
    setSearchResults([])
    setError(null)
    setIsSearching(false)
  }, [])

  return (
    <SearchContext.Provider 
      value={{
        searchTerm,
        isSearching,
        searchResults,
        error,
        inputValue,
        setInputValue,
        search,
        clearSearch
      }}
    >
      {children}
    </SearchContext.Provider>
  )
}

export function useSearch() {
  const context = useContext(SearchContext)
  if (!context) {
    throw new Error('useSearch must be used within a SearchProvider')
  }
  return context
}

================
File: src/contexts/PinnedContext.tsx
================
// src/contexts/PinnedContext.tsx
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react'
import { bookmarkService, pinService } from '~/services/bookmarks'
import type { BookmarkTreeNode } from '~/types/bookmark'

interface PinnedContextType {
  pinnedIds: Set<string>
  pinnedFolderIds: Set<string>
  isPinned: (id: string) => boolean
  isFolderPinned: (id: string) => boolean
  togglePin: (id: string) => Promise<void>
  toggleFolderPin: (id: string) => Promise<void>
  pinnedBookmarks: BookmarkTreeNode[]
  pinnedFolders: BookmarkTreeNode[]
  refreshPinnedItems: () => Promise<void>
}

const PinnedContext = createContext<PinnedContextType | null>(null)

export function PinnedProvider({ children }: { children: React.ReactNode }) {
  const [pinnedIds, setPinnedIds] = useState<Set<string>>(new Set())
  const [pinnedFolderIds, setPinnedFolderIds] = useState<Set<string>>(new Set())
  const [pinnedBookmarks, setPinnedBookmarks] = useState<BookmarkTreeNode[]>([])
  const [pinnedFolders, setPinnedFolders] = useState<BookmarkTreeNode[]>([])

  // 刷新固定项目
  const refreshPinnedItems = useCallback(async () => {
    try {
      const [bookmarks, folders] = await Promise.all([
        pinService.getPinnedBookmarks(),
        pinService.getPinnedFolders()
      ])
      setPinnedBookmarks(bookmarks)
      setPinnedFolders(folders)
    } catch (error) {
      console.error('Failed to refresh pinned items:', error)
    }
  }, [])

  // 加载初始数据
  useEffect(() => {
    const loadInitialData = async () => {
      try {
        const [bookmarkIds, folderIds] = await Promise.all([
          pinService.getPinnedBookmarkIds(),
          pinService.getPinnedFolderIds()
        ])
        setPinnedIds(new Set(bookmarkIds))
        setPinnedFolderIds(new Set(folderIds))
        await refreshPinnedItems()
      } catch (error) {
        console.error('Failed to load initial data:', error)
      }
    }
    
    loadInitialData()
  }, [refreshPinnedItems])

  const isPinned = useCallback((id: string) => pinnedIds.has(id), [pinnedIds])
  const isFolderPinned = useCallback((id: string) => pinnedFolderIds.has(id), [pinnedFolderIds])

  const togglePin = async (id: string) => {
    try {
      if (isPinned(id)) {
        await pinService.unpinBookmark(id)
        setPinnedIds(prev => {
          const next = new Set(prev)
          next.delete(id)
          return next
        })
      } else {
        await pinService.pinBookmark(id)
        setPinnedIds(prev => new Set([...prev, id]))
      }
      await refreshPinnedItems()
    } catch (error) {
      console.error('Failed to toggle pin:', error)
      throw error
    }
  }

  const toggleFolderPin = async (id: string) => {
    try {
      if (isFolderPinned(id)) {
        await pinService.unpinFolder(id)
        setPinnedFolderIds(prev => {
          const next = new Set(prev)
          next.delete(id)
          return next
        })
      } else {
        await pinService.pinFolder(id)
        setPinnedFolderIds(prev => new Set([...prev, id]))
      }
      await refreshPinnedItems()
    } catch (error) {
      console.error('Failed to toggle folder pin:', error)
      throw error
    }
  }

  return (
    <PinnedContext.Provider value={{
      pinnedIds,
      pinnedFolderIds,
      isPinned,
      isFolderPinned,
      togglePin,
      toggleFolderPin,
      pinnedBookmarks,
      pinnedFolders,
      refreshPinnedItems
    }}>
      {children}
    </PinnedContext.Provider>
  )
}

export const usePinned = () => {
  const context = useContext(PinnedContext)
  if (!context) {
    throw new Error('usePinned must be used within a PinnedProvider')
  }
  return context
}

================
File: src/contexts/ThemeContext.tsx
================
import React, { createContext, useContext, useEffect, useState } from "react"
import { themeStorage } from "~/services/storage/theme"

type Theme = 'light' | 'dark'

interface ThemeContextType {
  theme: Theme
  toggleTheme: () => void
}

const ThemeContext = createContext<ThemeContextType | null>(null)

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>('light')

  useEffect(() => {
    // 加载保存的主题设置
    const loadTheme = async () => {
      const savedTheme = await themeStorage.getTheme()
      if (savedTheme) {
        setTheme(savedTheme)
        document.documentElement.classList.toggle('dark', savedTheme === 'dark')
      } else {
        // 如果没有保存的主题，使用系统主题
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
        setTheme(prefersDark ? 'dark' : 'light')
        document.documentElement.classList.toggle('dark', prefersDark)
      }
    }
    loadTheme()
  }, [])

  const toggleTheme = async () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    document.documentElement.classList.toggle('dark', newTheme === 'dark')
    await themeStorage.setTheme(newTheme)
  }

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

export function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }
  return context
}

================
File: src/contexts/CommandContext.tsx
================
// src/contexts/CommandContext.tsx
import React, { createContext, useContext, useState, useCallback } from 'react'
import type { Command } from '~/types/command'
import { useToast } from '~/hooks/use-toast'
import { CreateFolderDrawer } from '~/components/folder/CreateFolderDrawer'
import { useSearch } from './SearchContext'
import { FolderPlus, Bookmark } from 'lucide-react'  


interface CommandContextType {
  isCommandMode: boolean
  commands: Command[]
  enterCommandMode: () => void
  exitCommandMode: () => void
  executeCommand: (commandId: string) => Promise<void>
}

const CommandContext = createContext<CommandContextType | null>(null)

export function CommandProvider({ children }: { children: React.ReactNode }) {

  const { clearSearch } = useSearch() 
  const [isCommandMode, setIsCommandMode] = useState(false)
  const [showCreateFolder, setShowCreateFolder] = useState(false)

  const { toast } = useToast()

  // 创建文件夹命令
  const exitCommandMode = useCallback(() => {
    setIsCommandMode(false)
    clearSearch() // 确保退出命令模式时也清除搜索
  }, [clearSearch])

  // 创建文件夹命令
  const createFolder = async () => {
    setShowCreateFolder(true)
    exitCommandMode() // 使用 exitCommandMode 来确保清除搜索
  }


  // 定义命令列表
  const commands: Command[] = [
    {
      id: 'create-folder',
      label: '新建文件夹',
      icon: FolderPlus,
      shortcut: '⏎',
      action: createFolder
    },
    {
      id: 'open-bookmark-manager',
      label: '打开书签管理器',
      icon: Bookmark,
      shortcut: '⏎',
      action: async () => {
        try {
          // 使用 chrome.tabs API 打开书签管理页面
          await chrome.tabs.create({ url: 'chrome://bookmarks/' })
          exitCommandMode() // 关闭命令模式
        } catch (error) {
          console.error('Failed to open bookmark manager:', error)
          toast({
            title: "错误",
            description: "无法打开书签管理器",
            variant: "destructive"
          })
        }
      }
    }
  ]

  const enterCommandMode = useCallback(() => {
    setIsCommandMode(true)
  }, [])

  const executeCommand = useCallback(async (commandId: string) => {
    const command = commands.find(cmd => cmd.id === commandId)
    if (command) {
      await command.action()
      exitCommandMode()
    }
  }, [commands, exitCommandMode])

  return (
    <CommandContext.Provider
      value={{
        isCommandMode,
        commands,
        enterCommandMode,
        exitCommandMode,
        executeCommand
      }}>
      {children}
      <CreateFolderDrawer 
        open={showCreateFolder}
        onOpenChange={(open) => {
          setShowCreateFolder(open)
          if (!open) {
            clearSearch() // 确保关闭抽屉时清除搜索
          }
        }}
        onSuccess={() => {
          // 可以在这里添加刷新书签列表等逻辑
        }}
      />
    </CommandContext.Provider>
  )
}

export function useCommand() {
  const context = useContext(CommandContext)
  if (!context) {
    throw new Error('useCommand must be used within a CommandProvider')
  }
  return context
}

================
File: src/contexts/TabContext.tsx
================
// src/contexts/TabContext.tsx
import React, { createContext, useContext, useCallback } from 'react'
import { settingsStorage } from "~/services/storage"
import { useSearch } from "./SearchContext"
import type { TabType } from '~/types/tab'

interface TabContextType {
  activeTab: TabType
  setActiveTab: (tab: TabType) => Promise<void>  // 改为异步方法
}

const TabContext = createContext<TabContextType | null>(null)

export function TabProvider({ children }: { children: React.ReactNode }) {
  const [activeTab, setActiveTab] = React.useState<TabType>('all')
  const { clearSearch } = useSearch()

  // 包含原有的 handleTabChange 逻辑
  const handleTabChange = useCallback(async (tab: TabType) => {
    setActiveTab(tab)
    clearSearch() // 清除搜索状态

    // 保存当前活动标签到存储
    try {
      await chrome.storage.local.set({ activeTab: tab })
    } catch (error) {
      console.error("Failed to save active tab:", error)
    }
  }, [clearSearch])

  return (
    <TabContext.Provider value={{ 
      activeTab, 
      setActiveTab: handleTabChange  // 使用包含完整逻辑的方法
    }}>
      {children}
    </TabContext.Provider>
  )
}

export function useTabs() {
  const context = useContext(TabContext)
  if (!context) {
    throw new Error('useTabs must be used within a TabProvider')
  }
  return context
}

================
File: src/config/bookmark.ts
================
export const BOOKMARK_CONFIG = {
  // 删除确认相关配置
  delete: {
    // 删除确认倒计时时间(秒)
    confirmDuration: 10,
    // 删除确认进度条动画时间(秒)
    progressDuration: 10,
  }
} as const

================
File: src/config/tabs.ts
================
// src/config/tabs.ts
import { Bookmark, Clock, Pin, Tag, Flame } from "lucide-react"
import type { LucideIcon } from "lucide-react"
import type { TabType } from "~/types/tab"

export interface TabConfig {
  id: TabType
  icon: LucideIcon
  label: string
  description: string
}

export const TABS: TabConfig[] = [
  {
    id: "all",
    icon: Bookmark,
    label: "ALL",
    description: "显示所有书签",
  },
  {
    id: "hot",
    icon: Flame,
    label: "HOT",
    description: "显示最常访问的书签",
  },
  {
    id: "recent",
    icon: Clock,
    label: "RECENT",
    description: "显示最近添加的书签",
  },
  {
    id: "pinned",
    icon: Pin,
    label: "PINNED",
    description: "显示已固定的书签",
  },
  {
    id: "tag",
    icon: Tag,
    label: "TAGS",
    description: "管理书签标签",
  },
]

// 获取 tab 配置的辅助函数
export function getTabConfig(id: TabType): TabConfig {
  const config = TABS.find(tab => tab.id === id)
  if (!config) {
    throw new Error(`Invalid tab id: ${id}`)
  }
  return config
}

// 获取所有 tab 选项的辅助函数
export function getTabOptions() {
  return TABS.map(({ id, label }) => ({
    value: id,
    label,
  }))
}

================
File: src/config/tagTemplates.ts
================
// src/config/tagTemplates.ts
import { Github, Youtube, ShoppingCart, Book, Code, Mail } from "lucide-react"
import type { TagTemplate } from "~/types/tag"

export const TAG_TEMPLATES: TagTemplate[] = [
  {
    id: "github",
    name: "GitHub 项目",
    description: "GitHub 相关的项目和仓库",
    icon: Github,
    conditions: {
      urlKeywords: ["github.com"],
      titleKeywords: ["repo", "github"]
    }
  },
  {
    id: "youtube",
    name: "YouTube 视频",
    description: "YouTube 视频和频道",
    icon: Youtube,
    conditions: {
      urlKeywords: ["youtube.com", "youtu.be"],
      titleKeywords: []
    }
  },
  {
    id: "shopping",
    name: "购物网站",
    description: "电商和购物相关网站", 
    icon: ShoppingCart,
    conditions: {
      urlKeywords: ["taobao.com", "jd.com", "tmall.com", "amazon"],
      titleKeywords: ["购买", "商品", "shop"]
    }
  },
  {
    id: "tutorial",
    name: "教程文档",
    description: "学习资源和教程",
    icon: Book,
    conditions: {
      urlKeywords: ["docs.", "tutorial", "learn"],
      titleKeywords: ["教程", "指南", "学习", "tutorial", "guide"]
    }
  },
  // 可以继续添加更多模板...
]

================
File: src/auth/index.ts
================
// src/auth/index.ts
export * from './components/GithubAuthButton'
export * from './components/UserProfile'
export * from './components/AuthCallback'
export * from './providers/github'
export * from './stores/auth'
export * from './types'

================
File: src/auth/types/index.ts
================
// src/auth/types/index.ts
export interface AuthUser {
    id: string
    username: string
    avatarUrl: string
    provider: 'github' | 'notion'
  }
  
  export interface AuthSession {
    user: AuthUser
    accessToken: string
    provider: 'github' | 'notion'
  }
  
  export interface AuthError {
    message: string
    code?: string
  }
  
  export type AuthStatus = 'authenticated' | 'unauthenticated' | 'loading'

================
File: src/auth/providers/base.ts
================
// src/auth/providers/base.ts
import type { Provider } from '@supabase/supabase-js'
import type { SupabaseClient } from '@supabase/supabase-js'
import type { AuthSession, AuthError } from '../types'

export interface AuthProvider {
  id: Provider
  name: string
  signIn(): Promise<{ provider: Provider; url: string } | null>
  signOut(): Promise<void>
  handleCallback(params: URLSearchParams): Promise<AuthSession>
  getSession(): Promise<AuthSession | null>
}

export abstract class BaseAuthProvider implements AuthProvider {
  abstract readonly id: Provider
  abstract readonly name: string
  
  protected constructor(
    protected readonly supabase: SupabaseClient
  ) {}

  abstract signIn(): Promise<{ provider: Provider; url: string } | null>
  abstract signOut(): Promise<void>
  abstract handleCallback(params: URLSearchParams): Promise<AuthSession>
  abstract getSession(): Promise<AuthSession | null>
  
  protected handleError(error: any): AuthError {
    console.error(`[${this.name} Auth Error]`, error)
    return {
      message: error.message || '认证失败',
      code: error.code
    }
  }
}

================
File: src/auth/providers/github.ts
================
// src/auth/providers/github.ts
import type { Provider } from '@supabase/supabase-js'
import { BaseAuthProvider } from './base'
import { supabaseService } from '../services/supabase'
import { AUTH_PROVIDERS } from '../services/supabase/config'
import type { AuthSession } from '../types'

export class GithubAuthProvider extends BaseAuthProvider {
  readonly id = AUTH_PROVIDERS.GITHUB.id as Provider
  readonly name = AUTH_PROVIDERS.GITHUB.name

  constructor() {
    super(supabaseService.client)
  }

  async signIn(): Promise<{ provider: Provider; url: string } | null> {
    const { data, error } = await this.supabase.auth.signInWithOAuth({
      provider: this.id,
      options: {
        redirectTo: supabaseService.getRedirectUrl(),
        scopes: AUTH_PROVIDERS.GITHUB.scopes
      }
    })

    if (error) throw this.handleError(error)
    return data
  }


  async signOut(): Promise<void> {
    const { error } = await this.supabase.auth.signOut()
    if (error) throw this.handleError(error)
  }

  async handleCallback(params: URLSearchParams): Promise<AuthSession> {
    const { data: { session }, error } = await this.supabase.auth.getSession()
    
    if (error) throw this.handleError(error)
    if (!session) throw this.handleError(new Error('No session'))

    return this.formatSession(session)
  }

  async getSession(): Promise<AuthSession | null> {
    try {
      const { data: { session }, error } = await this.supabase.auth.getSession()
      
      if (error) throw this.handleError(error)
      if (!session) return null

      return {
        user: {
          id: session.user.id,
          username: session.user.user_metadata.user_name,
          avatarUrl: session.user.user_metadata.avatar_url,
          provider: 'github'
        },
        accessToken: session.provider_token ?? '',
        provider: 'github'
      }
    } catch (error) {
      console.error('Get session error:', error)
      return null
    }
  }

  private formatSession(session: any): AuthSession {
    return {
      user: {
        id: session.user.id,
        username: session.user.user_metadata.user_name,
        avatarUrl: session.user.user_metadata.avatar_url,
        provider: this.id as "github"
      },
      accessToken: session.provider_token,
      provider: this.id as "github"
    }
  }
}

export const githubAuth = new GithubAuthProvider()

================
File: src/auth/stores/auth.ts
================
// src/auth/stores/auth.ts
import { create } from 'zustand'
import { githubAuth } from '../providers/github'
import type { AuthSession, AuthStatus } from '../types'

interface AuthStore {
  session: AuthSession | null
  status: AuthStatus
  setSession: (session: AuthSession | null) => void
  setStatus: (status: AuthStatus) => void
  initialize: () => Promise<void>
}

export const useAuthStore = create<AuthStore>((set) => ({
  session: null,
  status: 'loading',
  setSession: (session) => set({ session }),
  setStatus: (status) => set({ status }),
  initialize: async () => {
    try {
      const session = await githubAuth.getSession()
      set({ 
        session, 
        status: session ? 'authenticated' : 'unauthenticated' 
      })
    } catch (error) {
      console.error('Failed to initialize auth:', error)
      set({ status: 'unauthenticated' })
    }
  }
}))

================
File: src/auth/components/GithubAuthButton.tsx
================
// src/auth/components/GithubAuthButton.tsx
import React, { useState } from 'react'
import { Github } from 'lucide-react'
import { Button } from '~/components/ui/button'
import { useToast } from '~/hooks/use-toast'
import { githubAuth } from '../providers/github'
import { cn } from '~/lib/utils'

export const GithubAuthButton: React.FC = () => {
  const [isLoading, setIsLoading] = useState(false)
  const { toast } = useToast()

  const handleSignIn = async () => {
    console.log('Starting GitHub sign in...')
    try {
      setIsLoading(true)
      const result = await githubAuth.signIn()
      console.log('Sign in result:', result)
      
      // 使用 chrome.tabs.create 在新标签页打开认证页面
      if (result?.url) {
        console.log('Opening auth URL:', result.url)
        await chrome.tabs.create({ url: result.url })
        
        // 可选：关闭当前的 side panel
        await chrome.sidePanel.setOptions({ open: false })
      }
    } catch (error) {
      console.error('Sign in error:', error)
      toast({
        title: '登录失败',
        description: error instanceof Error ? error.message : '请稍后重试',
        variant: 'destructive'
      })
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <Button
      onClick={handleSignIn}
      disabled={isLoading}
      className={cn(
        "flex items-center gap-2",
        "bg-[#24292e] hover:bg-[#1c2127]",
        "text-white"
      )}
    >
      <Github className="w-4 h-4" />
      {isLoading ? '登录中...' : '使用 GitHub 登录'}
    </Button>
  )
}

================
File: src/auth/components/UserProfile.tsx
================
// src/auth/components/UserProfile.tsx
import React, { useState } from 'react'
import { LogOut } from 'lucide-react'
import { Button } from '~/components/ui/button'
import { useToast } from '~/hooks/use-toast'
import { githubAuth } from '../providers/github'
import type { AuthUser } from '../types'

interface UserProfileProps {
  user: AuthUser
  onSignOut: () => void
}

export const UserProfile: React.FC<UserProfileProps> = ({ user, onSignOut }) => {
  const [isLoading, setIsLoading] = useState(false)
  const { toast } = useToast()

  const handleSignOut = async () => {
    try {
      setIsLoading(true)
      await githubAuth.signOut()
      onSignOut()
    } catch (error: any) {
      toast({
        title: '退出失败',
        description: error.message,
        variant: 'destructive'
      })
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="flex items-center gap-4">
      <div className="flex items-center gap-2">
        <img 
          src={user.avatarUrl} 
          alt={user.username}
          className="w-8 h-8 rounded-full"
        />
        <span className="text-sm font-medium">
          {user.username}
        </span>
      </div>
      <Button
        variant="ghost"
        size="sm"
        onClick={handleSignOut}
        disabled={isLoading}
      >
        <LogOut className="w-4 h-4 mr-2" />
        退出
      </Button>
    </div>
  )
}

================
File: src/auth/components/AuthCallback.tsx
================
// src/auth/components/AuthCallback.tsx
import React, { useEffect } from 'react'
import { useLocation, useNavigate } from 'react-router-dom'
import { useAuthStore } from '../stores/auth'
import { githubAuth } from '../providers/github'

export const AuthCallback: React.FC = () => {
  const location = useLocation()
  const navigate = useNavigate()
  const { setSession, setStatus } = useAuthStore()

  useEffect(() => {
    const handleCallback = async () => {
      try {
        setStatus('loading')
        const params = new URLSearchParams(location.hash.substring(1))
        const session = await githubAuth.handleCallback(params)
        setSession(session)
        setStatus('authenticated')
        navigate('/')
      } catch (error) {
        console.error('Auth callback error:', error)
        setStatus('unauthenticated')
        navigate('/settings')
      }
    }

    if (location.hash.includes('access_token')) {
      handleCallback()
    }
  }, [location])

  return null
}

================
File: src/auth/services/supabase/types.ts
================
// src/services/supabase/types.ts
import type { SupabaseClient, User } from '@supabase/supabase-js'

export interface SupabaseSession {
  user: User
  access_token: string
  provider_token: string
  provider_refresh_token?: string
  expires_in: number
}

export type SupabaseService = {
  client: SupabaseClient
  getRedirectUrl(): string
}

================
File: src/auth/services/supabase/client.ts
================
// src/services/supabase/client.ts
import { createClient, SupabaseClient } from '@supabase/supabase-js'
import { SUPABASE_CONFIG } from './config'
import type { SupabaseService } from './types'

class SupabaseClientService implements SupabaseService {
  readonly client: SupabaseClient

  constructor() {
    this.client = createClient(
      SUPABASE_CONFIG.url,
      SUPABASE_CONFIG.anonKey
    )
  }

  getRedirectUrl(): string {
    return chrome.runtime.getURL(
      `sidepanel.html#${SUPABASE_CONFIG.authRedirectPath}`
    )
  }
}

export const supabaseService = new SupabaseClientService()

================
File: src/auth/services/supabase/index.ts
================
// src/services/supabase/index.ts
export * from './client'
export * from './config'
export * from './types'

================
File: src/auth/services/supabase/config.ts
================
// src/services/supabase/config.ts
export const SUPABASE_CONFIG = {
    url: process.env.PLASMO_PUBLIC_SUPABASE_URL,
    anonKey: process.env.PLASMO_PUBLIC_SUPABASE_KEY,
    authRedirectPath: '/auth/callback',
  } as const
  
  // 认证提供者配置
  export const AUTH_PROVIDERS = {
  GITHUB: {
    id: 'github',
    name: 'GitHub',
    scopes: 'gist'
  }
} as const

================
File: src/sidepanel/index.tsx
================
// src/sidepanel/index.tsx
import { Card } from "~/components/ui/card"
import BottomNav from "~/components/BottomNav"
import TagView from "~/components/views/TagView"
import AllView from "~/components/views/AllView"
import RecentView from "~/components/views/RecentView"
import PinView from "~/components/views/PinView"
import HotView from "~/components/views/HotView"
import { PinnedProvider } from "~/contexts/PinnedContext"
import { SearchProvider } from "~/contexts/SearchContext"
import { ThemeProvider } from "~/contexts/ThemeContext"
import { CommandProvider } from "~/contexts/CommandContext"
import { TabProvider, useTabs } from "~/contexts/TabContext"
import { Toaster } from 'react-hot-toast'
import type { TabType } from "~/types/tab"
import "~/styles/globals.css"

const SidePanelContent = () => {
  const { activeTab } = useTabs()

  // 根据当前标签渲染对应视图
  const renderView = () => {
    switch (activeTab) {
      case "hot":
        return <HotView activeTab={activeTab} />
      case "recent":
        return <RecentView activeTab={activeTab} />
      case "pinned":
        return <PinView activeTab={activeTab} />
      case "tag":
        return <TagView activeTab={activeTab} />
      default:
        return <AllView activeTab={activeTab} />
    }
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Card className="w-full border-none shadow-none bg-transparent flex-1">
        {renderView()}
      </Card>

      <BottomNav 
        activeTab={activeTab} 
      />
    </div>
  )
}

// 主组件
const SidePanel = () => {
  return (
    <SearchProvider>
      <ThemeProvider>
        <TabProvider>
          <CommandProvider>
            <PinnedProvider>
              <SidePanelContent />
              <Toaster 
                position="top-center"
                toastOptions={{
                  duration: 3000
                }}
              />
            </PinnedProvider>
          </CommandProvider>
        </TabProvider>
      </ThemeProvider>
    </SearchProvider>
  )
}

export default SidePanel

================
File: src/styles/globals.css
================
/* globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 210 60% 98%;
    --foreground: 210 40% 20%;
    --card: 210 20% 95%;
    --card-foreground: 210 40% 20%;
    --popover: 210 30% 100%;
    --popover-foreground: 210 40% 20%;
    --primary: 210 70% 60%;
    --primary-foreground: 210 10% 10%;
    --secondary: 210 40% 80%;
    --secondary-foreground: 210 30% 20%;
    --muted: 210 10% 90%;
    --muted-foreground: 210 20% 20%;
    --accent: 210 80% 70%;
    --accent-foreground: 210 10% 10%;
    --destructive: 0 100% 60%;
    --destructive-foreground: 0 100% 10%;
    --border: 210 20% 85%;
    --input: 0 0% 100%;
    --ring: 210 70% 80%;
    --radius: 0.5rem;

    --red-primary: 3 62% 42%;
    --red-secondary: 5 61% 54%;
    --orange-primary: 22 80% 41%;
    --orange-secondary: 23 70% 51%;
    --yellow-primary: 45 99% 34%;
    --yellow-secondary: 45 82% 45%;
    --green-primary: 73 84% 27%;
    --green-secondary: 72 46% 41%;
    --cyan-primary: 175 57% 33%;
    --cyan-secondary: 175 49% 45%;
    --blue-primary: 212 68% 39%;
    --blue-secondary: 208 49% 50%;
    --purple-primary: 259 42% 43%;
    --purple-secondary: 251 40% 64%;
    --magenta-primary: 326 55% 41%;
    --magenta-secondary: 329 54% 59%;
    --chart-1: 210 70% 40%;
    --chart-2: 210 90% 60%;
    --chart-3: 210 30% 80%;
    --chart-4: 210 50% 90%;
    --chart-5: 210 10% 70%;
  }

  .dark {
    --background: 222 16% 8%; /* #0F1117 */
    --foreground: 220 12% 93%; /* #EBEDEF */
    --card: 222 15% 12%; /* #1A1C24 */
    --card-foreground: 220 12% 93%;
    --popover: 222 15% 12%;
    --popover-foreground: 220 12% 93%;
    --primary: 222 15% 12%;
    --primary-foreground: 220 12% 93%;
    --secondary: 223 14% 15%; /* #202229 */
    --secondary-foreground: 220 12% 93%;
    --muted: 223 14% 15%;
    --muted-foreground: 220 8% 65%; /* #9CA0A8 */
    --accent: 223 14% 15%;
    --accent-foreground: 220 12% 93%;
    --border: 225 9% 19%; /* #2D2F36 */
    --ring: 225 9% 19%;

    --red-primary: 5 61% 54%;
    --red-secondary: 3 62% 42%;
    --orange-primary: 23 70% 51%;
    --orange-secondary: 22 80% 41%;
    --yellow-primary: 45 82% 45%;
    --yellow-secondary: 45 99% 34%;
    --green-primary: 72 46% 41%;
    --green-secondary: 73 84% 27%;
    --cyan-primary: 175 49% 45%;
    --cyan-secondary: 175 57% 33%;
    --blue-primary: 208 49% 50%;
    --blue-secondary: 212 68% 39%;
    --purple-primary: 251 40% 64%;
    --purple-secondary: 259 42% 43%;
    --magenta-primary: 329 54% 59%;
    --magenta-secondary: 326 55% 41%;
    --chart-1: 210 40% 70%;
    --chart-2: 210 80% 50%;
    --chart-3: 210 30% 60%;
    --chart-4: 210 90% 40%;
    --chart-5: 210 10% 30%;
  }

  * {
    border: 0 solid transparent;
  }

  .border-enabled {
    @apply border-border;
  }

  .tag-form-content {
    border: none !important;
  }
}


@layer utilities {
  .custom-scrollbar {
    /* Firefox */
    scrollbar-width: thin;
    scrollbar-color: hsl(var(--muted)) transparent;
  }

  /* Webkit/Chromium */
  .custom-scrollbar::-webkit-scrollbar {
    width: 6px;
    height: 6px; /* 添加水平滚动条支持 */
  }

  .custom-scrollbar::-webkit-scrollbar-track {
    background: transparent;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb {
    @apply bg-muted rounded-full;
    border: 2px solid transparent;
    background-clip: padding-box;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    @apply bg-muted-foreground/50;
  }

  .custom-scrollbar::-webkit-scrollbar-corner {
    background: transparent;
  }

  /* 暗色模式专门的样式 */
  .dark .custom-scrollbar {
    scrollbar-color: hsl(var(--muted-foreground)) transparent;
  }

  /* 当滚动容器背景色较深时使用 */
  .custom-scrollbar-dark {
    scrollbar-color: hsl(var(--muted-foreground)) transparent;
  }

  .custom-scrollbar-dark::-webkit-scrollbar-thumb {
    @apply bg-muted-foreground/50;
  }

  .custom-scrollbar-dark::-webkit-scrollbar-thumb:hover {
    @apply bg-muted-foreground;
  }

  .bookmark-item .bookmark-group:hover .bookmark-group-hover\:opacity-100 {
    opacity: 1;
  }

  .tag-form-content.tag-form-content {
    @apply border-0;
  }
}



@layer base {
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}

@keyframes float {
  0% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-4px);
  }
  100% {
    transform: translateY(0px);
  }
}

.float-animation:hover {
  animation: float 2s ease-in-out infinite;
}

================
File: src/components/BottomNav.tsx
================
// src/components/BottomNav.tsx
import React, { useEffect, useState } from "react"
import { cn } from "~/lib/utils"
import { TABS } from "~/config/tabs"
import { settingsStorage } from "~/services/storage"
import { useTabs } from "~/contexts/TabContext"  // 导入 useTabs
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "~/components/ui/tooltip"
import type { TabType } from "~/types/tab"

interface BottomNavProps {
  activeTab: TabType  // 只保留 activeTab props
}

const BottomNav: React.FC<BottomNavProps> = ({ activeTab }) => {
  const [defaultTab, setDefaultTab] = useState<TabType>("all")
  const { setActiveTab } = useTabs()  // 使用 hook 获取 setActiveTab

  useEffect(() => {
    const loadDefaultTab = async () => {
      const settings = await settingsStorage.getSettings()
      setDefaultTab(settings.defaultTab)
    }
    loadDefaultTab()
  }, [])

  return (
    <div className={cn(
      "fixed bottom-0 left-0 right-0",
      "bg-background border-t border-border",
      "shadow-sm backdrop-blur supports-[backdrop-filter]:bg-background/60"
    )}>
      <div className="flex items-center justify-around">
        {TABS.map((tab) => {
          const Icon = tab.icon
          const isActive = activeTab === tab.id
          const isDefault = defaultTab === tab.id

          return (
            <TooltipProvider key={tab.id}>
              <Tooltip>
                <TooltipTrigger asChild>
                  <button
                    onClick={() => setActiveTab(tab.id)}  // 直接使用 setActiveTab
                    className={cn(
                      "flex flex-1 flex-col items-center justify-center py-2 px-4",
                      "text-xs transition-all relative",
                      isDefault && !isActive && [
                        "bg-gradient-to-b from-primary/5 to-transparent",
                        "dark:from-primary/10"
                      ],
                      isActive ? [
                        "text-primary hover:text-primary/90",
                        "dark:text-[#EBEDEF]"
                      ] : [
                        "text-muted-foreground",
                        "hover:text-foreground",
                        "dark:text-[#9CA0A8]",
                        "dark:hover:text-[#EBEDEF]"
                      ]
                    )}
                    aria-label={tab.description}
                  >
                    <Icon 
                      className={cn(
                        "h-5 w-5 mb-1",
                        "transition-transform duration-200",
                        isDefault && !isActive && [
                          "opacity-90",
                          "dark:opacity-80",
                          "filter drop-shadow-[0_0_2px_rgba(var(--primary),.3)]",
                          "dark:drop-shadow-[0_0_3px_rgba(255,255,255,.15)]"
                        ]
                      )} 
                    />
                    <span className={cn(
                      isDefault && !isActive && [
                        "font-medium",
                        "opacity-90",
                        "dark:opacity-80"
                      ]
                    )}>
                      {tab.label}
                    </span>
                    {isActive && (
                      <span className={cn(
                        "absolute -top-px left-0 right-0 h-0.5",
                        "bg-primary dark:bg-cyan-400"
                      )} />
                    )}
                    {isDefault && !isActive && (
                      <span className={cn(
                        "absolute -bottom-px left-1/4 right-1/4 h-[2px]",
                        "bg-primary/20 dark:bg-primary/30",
                        "rounded-full"
                      )} />
                    )}
                  </button>
                </TooltipTrigger>
                <TooltipContent 
                  side="top" 
                  className={cn(
                    "text-xs",
                    isDefault && [
                      "text-primary",
                      "dark:text-cyan-400",
                      "dark:drop-shadow-[0_0_3px_rgba(34,211,238,0.3)]"
                    ]
                  )}
                >
                  <p className="flex items-center gap-1.5">
                    {isDefault && (
                      <span className={cn(
                        "inline-block w-1 h-1 rounded-full",
                        "bg-primary dark:bg-cyan-400",
                        "dark:shadow-[0_0_4px_rgba(34,211,238,0.4)]"
                      )} />
                    )}
                    {tab.description}
                    {isDefault && (
                      <span className="opacity-85">
                        (默认页面)
                      </span>
                    )}
                  </p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )
        })}
      </div>
    </div>
  )
}

export default BottomNav

================
File: src/components/SettingsView.tsx
================
// src/components/SettingsView.tsx
import React, { useEffect, useState } from "react"
import { X } from "lucide-react"
import { Button } from "./ui/button"
import { Label } from "./ui/label"
import { cn } from "~/lib/utils"
import { settingsStorage } from "~/services/storage"
import type { Settings } from "~/types/settings"
import type { TabType } from "~/types/tab"
import { getTabOptions } from "~/config/tabs"
import { motion, AnimatePresence } from "framer-motion"
import { GithubBackupSection } from "./settings/GithubBackupSection"

interface SettingsViewProps {
  onClose: () => void
}

const SettingsView: React.FC<SettingsViewProps> = ({ onClose }) => {

  const [settings, setSettings] = useState<Settings>()
  const [isSaving, setIsSaving] = useState(false)

  // 加载设置
  useEffect(() => {
    const loadSettings = async () => {
      const settings = await settingsStorage.getSettings()
      setSettings(settings)
    }
    loadSettings()
  }, [])

  // 保存默认标签设置
  const handleTabChange = async (tab: TabType) => {
    if (!settings) return
    
    try {
      setIsSaving(true)
      const newSettings = await settingsStorage.updateSettings({
        defaultTab: tab
      })
      setSettings(newSettings)
    } catch (error) {
      console.error('Failed to update default tab:', error)
    } finally {
      setIsSaving(false)
    }
  }

  if (!settings) return null

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.2 }}
        className="fixed inset-0 bg-background/80 backdrop-blur-sm z-50"
      >
        <motion.div
          initial={{ scale: 0.95, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.95, opacity: 0 }}
          transition={{
            duration: 0.2,
            ease: [0.4, 0, 0.2, 1]
          }}
          className="fixed inset-0 bg-background rounded-lg border shadow-lg overflow-hidden"
        >
          {/* 顶部标题栏 */}
          <div className="flex items-center justify-between px-4 py-2 border-b">
            <h3 className="text-base font-medium">{chrome.i18n.getMessage("settings")}</h3>
            <Button 
              variant="ghost" 
              size="icon"
              className="h-8 w-8 hover:bg-muted/50" 
              onClick={onClose}
            >
              <X className="h-4 w-4" />
              <span className="sr-only">{chrome.i18n.getMessage("settings_close")}</span>
            </Button>
          </div>

          {/* 设置内容区域 */}
          <div className="p-4 space-y-6">
            {/* 默认标签设置 */}
            <div className="space-y-2">
              <Label className="text-sm font-medium">{chrome.i18n.getMessage("settings_title")}</Label>
              <div className="grid grid-cols-2 gap-2">
                {getTabOptions().map((option) => (
                  <Button
                  key={option.value}
                  variant={settings.defaultTab === option.value ? "default" : "outline"}
                  className={cn(
                    "justify-start",
                    "transition-colors duration-200",
                    settings.defaultTab === option.value ? [
                      // 选中状态 
                      "bg-[#202229] text-[#EBEDEF] hover:bg-[#252832]",
                      "dark:bg-[#202229] dark:text-[#EBEDEF] dark:hover:bg-[#252832]"
                    ] : [
                      // 未选中状态
                      "bg-transparent border-[#2D2F36] text-foreground",
                      "hover:bg-[#1A1C24] hover:text-[#EBEDEF]",
                      "dark:border-[#2D2F36] dark:text-[#9CA0A8]",
                      "dark:hover:bg-[#202229] dark:hover:text-[#EBEDEF]"
                    ],
                    isSaving && "opacity-50 cursor-wait"
                  )}
                  disabled={isSaving}
                  onClick={() => handleTabChange(option.value)}
                 >
                  {option.label}
                 </Button>
                ))}
              </div>
              <p className="text-xs text-muted-foreground mt-1">
                {chrome.i18n.getMessage("settings_description")}
              </p>
            </div>

            <div className="space-y-2">
              <GithubBackupSection />
            </div>
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  )
}

export default SettingsView

================
File: src/components/SearchBar.tsx
================
// src/components/SearchBar.tsx
import React, { useEffect, useRef } from "react"
import { Search, X, Command } from "lucide-react"
import { cn } from "~/lib/utils"
import { Input } from "~/components/ui/input"
import { useSearch } from "~/contexts/SearchContext"
import { useCommand } from "~/contexts/CommandContext"
import { useDebounce } from "~/hooks/useDebounce"
import { CommandList } from "./CommandList"

interface SearchBarProps {
  className?: string
}

const SearchBar: React.FC<SearchBarProps> = ({ className }) => {
  const { 
    search, 
    clearSearch, 
    isSearching, 
    error,
    inputValue,
    setInputValue
  } = useSearch()

  const {
    isCommandMode,
    enterCommandMode,
    exitCommandMode,
    executeCommand
  } = useCommand()
  
  const inputRef = useRef<HTMLInputElement>(null)
  const debouncedValue = useDebounce(inputValue, 300)

  // 监听快捷键
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // 检查是否按下 Cmd/Ctrl + K
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault()
        inputRef.current?.focus()
      }
    }

    // 监听来自 background 的消息
    const handleMessage = (message: any) => {
      if (message.type === "FOCUS_SEARCH") {
        inputRef.current?.focus()
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    chrome.runtime.onMessage.addListener(handleMessage)

    return () => {
      document.removeEventListener('keydown', handleKeyDown)
      chrome.runtime.onMessage.removeListener(handleMessage)
    }
  }, [])

  // 处理搜索
  useEffect(() => {
    if (!isCommandMode) {
      search(debouncedValue)
    }
  }, [debouncedValue, search, isCommandMode])

  // 处理输入变化
  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const value = event.target.value
    setInputValue(value)
    
    // 如果在命令模式下删除了 "/"，退出命令模式
    if (isCommandMode && !value.startsWith('/')) {
      exitCommandMode()
    }
  }

  // 处理按键
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    // 处理 "/" 触发命令模式
    if (e.key === '/' && !isCommandMode && !inputValue) {
      e.preventDefault()
      enterCommandMode()
      setInputValue('/')
      return
    }

    // 处理 ESC 退出命令模式
    if (e.key === 'Escape') {
      if (isCommandMode) {
        e.preventDefault()
        exitCommandMode()
        setInputValue('')
      } else if (inputValue) {
        e.preventDefault()
        clearSearch()
      }
      return
    }
  }

  // 处理清除
  const handleClear = () => {
    clearSearch()
    exitCommandMode()
    inputRef.current?.focus()
  }

  return (
    <div className={cn("relative", className)}>
      <div className="relative flex items-center">
        <Search
          className={cn(
            "absolute left-2.5 top-2.5",
            "h-4 w-4",
            "text-muted-foreground",
            "pointer-events-none",
            isCommandMode && "text-blue-500"
          )}
        />

        <Input
          ref={inputRef}
          type="text"
          placeholder={
            error 
              ? error 
              : isCommandMode 
                ? "输入命令..." 
                : "搜索书签或输入 / 打开命令面板..."
          }
          value={inputValue}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          aria-label={isCommandMode ? "命令输入" : "搜索书签"}
          className={cn(
            "h-9",
            "pl-9 pr-16",
            "text-sm",
            "bg-muted/50",
            "border border-border/40",
            "ring-offset-background",
            "placeholder:text-muted-foreground/70",
            "hover:border-primary/30",
            "hover:bg-accent/30",
            "focus-visible:border-primary/50",
            "focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-primary/40",
            "transition-colors duration-200",
            error && "border-destructive/50 focus-visible:border-destructive",
            isCommandMode && "border-primary/50"
          )}
        />

        {/* 快捷键提示 */}
        <div className={cn(
          "absolute right-2",
          "flex items-center gap-1",
          "h-9",
          "text-xs text-muted-foreground",
          "pointer-events-none select-none",
          inputValue && "hidden"
        )}>
          <div className="flex items-center gap-1">
            <Command className="h-3 w-3" />
            <span>K</span>
          </div>
        </div>

        {/* 清除按钮 */}
        {inputValue && (
          <button
            onClick={handleClear}
            className={cn(
              "absolute right-2 top-2.5",
              "text-muted-foreground",
              "hover:text-foreground",
              "transition-colors"
            )}
          >
            {isSearching ? (
              <div className="h-4 w-4 border-2 border-current border-t-transparent rounded-full animate-spin" />
            ) : (
              <X className="h-4 w-4" />
            )}
            <span className="sr-only">
              {isCommandMode ? "清除命令" : "清除搜索"}
            </span>
          </button>
        )}
      </div>

      {/* 命令列表 */}
      {isCommandMode && (
        <CommandList
          onSelect={executeCommand}
          className="z-50"
        />
      )}

      {/* 错误提示 */}
      {error && !isCommandMode && (
        <div className="absolute top-full left-0 right-0 mt-1 px-2 py-1 text-xs text-destructive">
          {error}
        </div>
      )}
    </div>
  )
}

export default SearchBar

================
File: src/components/ThemeToggle.tsx
================
import React from "react"
import { Moon, Sun } from "lucide-react"
import { Button } from "~/components/ui/button"
import { cn } from "~/lib/utils"
import { useTheme } from "~/contexts/ThemeContext"

const ThemeToggle: React.FC<{ className?: string }> = ({ className }) => {
  const { theme, toggleTheme } = useTheme()

  return (
    <Button
      variant="ghost"
      size="icon"
      className={cn(
        "h-9 w-9",
        "text-muted-foreground",
        "hover:text-foreground",
        "hover:bg-muted/70",
        "transition-colors",
        className
      )}
      onClick={toggleTheme}
    >
      {theme === 'dark' ? (
        <Sun className="h-4 w-4" />
      ) : (
        <Moon className="h-4 w-4" />
      )}
      <span className="sr-only">
        切换{theme === 'dark' ? '亮色' : '暗色'}模式
      </span>
    </Button>
  )
}

export default ThemeToggle

================
File: src/components/CommandList.tsx
================
// src/components/CommandList.tsx
import React from "react"
import { cn } from "~/lib/utils"
import { useCommand } from "~/contexts/CommandContext"

export const CommandList: React.FC<CommandListProps> = ({
  onSelect,
  className
}) => {
  const { commands } = useCommand()

  return (
    <div className={cn(
      "absolute top-full left-0 right-0 mt-1",
      "overflow-hidden rounded-md",
      // 修改背景色和边框
      "bg-white dark:bg-[#202229]", // 稍微亮一点的背景色
      "border border-border/40",
      "dark:border-[#2D2F36]", // 更明显的边框色
      // 添加阴影效果增加层次感
      "shadow-lg",
      "dark:shadow-[0_4px_12px_rgba(0,0,0,0.5)]",
      className
    )}>
      <div className={cn(
        "p-1.5", // 减小内边距
        "text-xs text-muted-foreground",
        "border-b border-border/40",
        "dark:border-[#2D2F36]",
        // 添加半透明背景增加区分度
        "bg-muted/50",
        "dark:bg-[#252832]/50"
      )}>
        命令列表
      </div>
      
      <div className={cn(
        "max-h-[300px]",
        "overflow-y-auto",
        "custom-scrollbar",
        // 添加渐变背景
        "bg-gradient-to-b from-transparent to-muted/5",
        "dark:from-transparent dark:to-[#252832]/20"
      )}>
        {commands.map((command) => {
          const Icon = command.icon
          return (
            <button
              key={command.id}
              className={cn(
                "w-full",
                "flex items-center justify-between",
                "px-3 py-2", // 稍微增加点击区域
                "text-sm",
                // 默认状态
                "text-foreground/90",
                "dark:text-[#EBEDEF]",
                // 悬停状态
                "hover:bg-accent/80",
                "dark:hover:bg-[#252832]",
                "hover:text-foreground",
                "dark:hover:text-white",
                // 激活状态
                "active:bg-accent",
                "dark:active:bg-[#2D2F36]",
                // 转场动画
                "transition-all duration-200",
                // 添加微弱的边框效果
                "border-b border-border/5",
                "dark:border-[#2D2F36]/50",
                "last:border-0"
              )}
              onClick={() => onSelect(command.id)}
            >
              <div className="flex items-center gap-2.5">
                {Icon && (
                  <Icon 
                    className={cn(
                      "h-4 w-4",
                      // 图标颜色
                      "text-muted-foreground/70",
                      "dark:text-[#9CA0A8]",
                      "group-hover:text-foreground",
                      "dark:group-hover:text-white"
                    )} 
                  />
                )}
                <span className="font-medium">{command.label}</span>
              </div>
              
              {command.shortcut && (
                <kbd className={cn(
                  "px-1.5 py-0.5", // 减小快捷键标签尺寸
                  "text-xs",
                  "rounded",
                  // 快捷键样式
                  "bg-muted",
                  "dark:bg-[#1A1C24]",
                  "text-muted-foreground",
                  "dark:text-[#9CA0A8]",
                  "border border-border/10",
                  "dark:border-[#2D2F36]",
                  // 悬停效果
                  "group-hover:bg-accent/50",
                  "dark:group-hover:bg-[#252832]",
                  "group-hover:text-foreground",
                  "dark:group-hover:text-white"
                )}>
                  {command.shortcut}
                </kbd>
              )}
            </button>
          )
        })}
      </div>
    </div>
  )
}

================
File: src/components/SettingsButton.tsx
================
// src/components/SettingsButton.tsx
import React, { useState } from "react"
import { Settings } from "lucide-react"
import { Button } from "~/components/ui/button"
import { cn } from "~/lib/utils"
import SettingsView from "./SettingsView"
import { AnimatePresence } from "framer-motion"

interface SettingsButtonProps {
  className?: string
}

const SettingsButton: React.FC<SettingsButtonProps> = ({ className }) => {
  const [showSettings, setShowSettings] = useState(false)

  return (
    <>
      <Button
        variant="ghost"
        size="icon"
        className={cn(
          "h-9 w-9",
          "text-muted-foreground",
          "hover:text-foreground",
          "hover:bg-muted/70",
          "transition-colors",
          className
        )}
        onClick={() => setShowSettings(true)}
      >
        <Settings className="h-4 w-4" />
        <span className="sr-only">{chrome.i18n.getMessage("settings")}</span>
      </Button>

      <AnimatePresence>
        {showSettings && (
          <SettingsView onClose={() => setShowSettings(false)} />
        )}
      </AnimatePresence>
    </>
  )
}

export default SettingsButton

================
File: src/components/ViewHeader.tsx
================
// src/components/ViewHeader.tsx
import React from "react"
import { CardHeader } from "./ui/card"
import SearchBar from "./SearchBar"
import SettingsButton from "./SettingsButton"
import ThemeToggle from "./ThemeToggle"
import type { TabType } from "~/types/tab"

interface ViewHeaderProps {
  activeTab: TabType
}

const ViewHeader: React.FC<ViewHeaderProps> = ({ activeTab }) => {
  return (
    <CardHeader className="py-2 px-3">
      <div className="flex items-center gap-2">
        <SearchBar className="flex-1" />
        <ThemeToggle />
        <SettingsButton />
      </div>
    </CardHeader>
  )
}

export default ViewHeader

================
File: src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "~/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: src/components/ui/progress.tsx
================
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "~/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

================
File: src/components/ui/toaster.tsx
================
import { useToast } from "~/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "~/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: src/components/ui/hint-dialog.tsx
================
import { motion, AnimatePresence } from "framer-motion"
import { cn } from "~/lib/utils"
import { Button } from "./button"

interface HintDialogProps {
 open: boolean
 onConfirm: () => void
}

export const HintDialog = ({ open, onConfirm }: HintDialogProps) => {
    if (!open) return null
   
    return (
      <AnimatePresence>
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 bg-background/80 backdrop-blur-sm flex items-center justify-center"
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            transition={{ duration: 0.2 }}
            className={cn(
              "w-[90vw] max-w-[360px]",
              "rounded-lg",
              "bg-card p-4",
              "shadow-lg",
              "dark:bg-[#202229]", // 调深背景色
              "border border-border/40 dark:border-[#2D2F36]"
            )}
          >
            <div className={cn(
              "p-3 rounded-lg mb-3",
              "bg-muted/50",
              "dark:bg-[#1A1C24]", // 调深内容区背景
              "border border-border/40 dark:border-[#2D2F36]"
            )}>
              <div className="text-sm font-medium mb-2 dark:text-white">
                使用快捷键打开/关闭侧边栏
                <kbd className={cn(
                    "px-2.5 py-1.5", // 增大内边距
                    "ml-2",
                    "rounded text-xs font-mono",
                    "bg-background dark:bg-[#141414]", // 深色模式下更深的背景
                    "dark:text-cyan-500", // 强调文字颜色
                    "border border-border/40 dark:border-[#2D2F36]",
                    "shadow-sm"
                )}>
                    {navigator.platform.includes('Mac') ? '⌘+B' : 'Alt+B'}
                </kbd>
              </div>
            </div>
   
            <Button
              onClick={onConfirm}
              className={cn(
                "w-full",
                "bg-primary hover:bg-primary/90", // 亮色模式使用主色
                "dark:bg-cyan-600 dark:text-white", // 深色模式使用突出色
                "dark:hover:bg-cyan-700"
              )}
            >
              知道了
            </Button>
          </motion.div>
        </motion.div>
      </AnimatePresence>
    )
   }

================
File: src/components/ui/label.tsx
================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "~/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

================
File: src/components/ui/drawer.tsx
================
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "~/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

================
File: src/components/ui/tooltip.tsx
================
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "~/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: src/components/ui/dialog.tsx
================
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "~/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: src/components/ui/loading.tsx
================
// src/components/ui/loading.tsx
import React from 'react'
import { cn } from '~/lib/utils'

interface LoadingProps {
  size?: 'sm' | 'md' | 'lg'
  className?: string
}

export const Loading: React.FC<LoadingProps> = ({ 
  size = 'md',
  className 
}) => {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-5 w-5',
    lg: 'h-6 w-6'
  }

  return (
    <div className="flex items-center gap-2">
      <div 
        className={cn(
          "animate-spin rounded-full",
          "border-2 border-primary border-t-transparent",
          sizeClasses[size],
          className
        )} 
      />
      <span className="text-sm text-muted-foreground">
        加载中...
      </span>
    </div>
  )
}

================
File: src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "~/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: src/components/ui/toast.tsx
================
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "~/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: src/components/ui/select.tsx
================
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "~/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: src/components/ui/input.tsx
================
import * as React from "react"

import { cn } from "~/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-0 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: src/components/settings/GithubBackupSection.tsx
================
// src/components/settings/GithubBackupSection.tsx
import React, { useEffect } from 'react'
import { GithubAuthButton, UserProfile } from '~/auth'
import { useAuthStore } from '~/auth/stores/auth'
import { Loading } from '../ui/loading'

export const GithubBackupSection: React.FC = () => {
  const { session, status, initialize } = useAuthStore()

  useEffect(() => {
    initialize()
  }, [initialize])

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-medium">GitHub 备份</h3>
        
        {status === 'loading' ? (
           <div className="flex items-center justify-center p-4">
           <Loading />
         </div>
        ) : status === 'authenticated' && session?.provider === 'github' ? (
          <UserProfile 
            user={session.user} 
            onSignOut={() => {
              useAuthStore.setState({ 
                session: null,
                status: 'unauthenticated'
              })
            }}
          />
        ) : (
          <GithubAuthButton />
        )}
      </div>

      {status === 'authenticated' && session?.provider === 'github' && (
        <div className="space-y-2">
          {/* 备份配置选项 */}
        </div>
      )}
    </div>
  )
}

================
File: src/components/bookmark/BookmarkIcon.tsx
================
// src/components/BookmarkIcon.tsx
import React, { useState } from "react"
import { iconService } from "~/services/icons"
import { cn } from "~/lib/utils"

interface BookmarkIconProps {
  url?: string
  title: string
  isFolder: boolean
  className?: string
}

const BookmarkIcon: React.FC<BookmarkIconProps> = ({
  url,
  title,
  isFolder,
  className
}) => {
  const [imageError, setImageError] = useState(false)

// 文件夹图标样式
const folderStyles = cn(
  "flex items-center justify-center",
  "w-full h-full rounded-lg",
  "relative isolate overflow-hidden",
  // 使用正确的颜色引用语法
  "bg-primary text-primary-foreground",
  "before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/10",
  "ring-1 ring-ring/30 shadow-sm",
  className
)

// 链接图标样式
const linkStyles = cn(
  "flex items-center justify-center",
  "w-full h-full rounded-lg",
  "relative isolate overflow-hidden",
  "bg-card text-card-foreground",
  "before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/10",
  "ring-1 ring-border/20 shadow-sm",
  className
)

// 默认图标样式
const defaultStyles = cn(
  "flex items-center justify-center",
  "w-full h-full rounded-lg",
  "relative isolate overflow-hidden",
  "bg-muted text-muted-foreground",
  "before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/10",
  "ring-1 ring-border/20 shadow-sm",
  className
)

  // 文件夹图标处理
  if (isFolder) {
    const FolderIcon = iconService.getFolderIcon(title)
    return (
      <div className={folderStyles}>
        <FolderIcon className="h-5 w-5 text-white/90" />
      </div>
    )
  }

  // 网站图标处理
  if (url && !imageError) {
    const faviconUrl = iconService.getFaviconUrl(url)
    return (
      <div className={linkStyles}>
        <div className="relative flex items-center justify-center w-full h-full p-1">
          <img
            src={faviconUrl}
            className="w-5/6 h-5/6 object-contain"
            alt=""
            onError={() => setImageError(true)}
            loading="lazy"
          />
        </div>
      </div>
    )
  }

  // 默认字母图标处理
  const defaultIcon = title?.[0]?.toUpperCase() || '?'
  const colors = [
    'from-red-400 to-red-500 text-white',
    'from-blue-400 to-blue-500 text-white',
    'from-green-400 to-green-500 text-white',
    'from-yellow-400 to-yellow-500 text-white',
    'from-purple-400 to-purple-500 text-white',
    'from-pink-400 to-pink-500 text-white'
  ]
  const colorIndex = defaultIcon.charCodeAt(0) % colors.length
  const gradientColor = colors[colorIndex]

  return (
    <div className={cn(
      defaultStyles,
      "bg-gradient-to-br",
      gradientColor,
      // 添加悬停效果
      "transition-transform duration-200 ease-in-out",
      "hover:scale-105"
    )}>
      <div className="text-base font-semibold">
        {defaultIcon}
      </div>
    </div>
  )
}

export default BookmarkIcon

================
File: src/components/bookmark/BookmarkList.tsx
================
import React from "react"
import { cn } from "~/lib/utils"
import BookmarkItem from "./BookmarkItem"
import type { BookmarkTreeNode } from "~/types/bookmark"

interface BookmarkListProps {
  bookmarks: BookmarkTreeNode[]
  className?: string
}

const BookmarkList: React.FC<BookmarkListProps> = ({ 
  bookmarks, 
  className
}) => {
  return (
    <div className={cn(
      "space-y-[3px]",
      "px-1 py-1",
      "custom-scrollbar",
      className
    )}>
      {bookmarks.map((bookmark) => (
        <BookmarkItem 
          key={bookmark.id} 
          bookmark={bookmark}
        />
      ))}
    </div>
  )
}

export default BookmarkList

================
File: src/components/bookmark/BookmarkItem.tsx
================
// src/components/BookmarkItem.tsx
import React, { useState, useEffect, useRef } from "react"
import { ChevronRight} from "lucide-react"
import { Input } from "../ui/input"
import BookmarkIcon from "./BookmarkIcon"
import { cn, isToday } from "~/lib/utils"
import { usePinned } from "~/contexts/PinnedContext"
import type { BookmarkItemProps } from "~/types/bookmark"
import { descriptionStorage } from "~/services/storage"
import { visitStorage } from "~/services/storage/visit"
import { bookmarkService } from "~/services/bookmarks"
import { pinService } from "~/services/bookmarks"
import { EditButton } from "./buttons/EditButton"
import { PinButton } from "./buttons/PinButton"
import { DeleteButton } from "./buttons/DeleteButton"
import { BOOKMARK_CONFIG } from "~/config/bookmark"


// 工具函数
const getDisplayUrl = (url: string) => {
  try {
    const urlObject = new URL(url)
    return urlObject.hostname + urlObject.pathname
  } catch (e) {
    return url
  }
}

export const BookmarkItem: React.FC<BookmarkItemProps> = ({ 
  bookmark, 
  level = 0,
  className 
}) => {
  // 状态管理
  const [isExpanded, setIsExpanded] = useState(false)
  const [isPinning, setIsPinning] = useState(false)
  const [description, setDescription] = useState("")
  const [isEditingDescription, setIsEditingDescription] = useState(false)
  const [isLoadingDescription, setIsLoadingDescription] = useState(true)
  const { isPinned, togglePin, isFolderPinned, toggleFolderPin } = usePinned()
  const [isDeleting, setIsDeleting] = useState(false)
  const [isRemoving, setIsRemoving] = useState(false)
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)
  const [countdown, setCountdown] = useState(BOOKMARK_CONFIG.delete.confirmDuration)
  const countdownRef = useRef<NodeJS.Timeout>()
  const progressRef = useRef<NodeJS.Timeout>()

  const isFolder = !bookmark.url
  const isItemPinned = isFolder ? isFolderPinned(bookmark.id) : isPinned(bookmark.id)
  const displayUrl = bookmark.url ? getDisplayUrl(bookmark.url) : ''

  // 描述编辑引用
  const descriptionInputRef = useRef<HTMLInputElement>(null)

  // 添加 ref 用于获取 DOM 元素
  const itemRef = useRef<HTMLDivElement>(null)

  // 加载描述
  useEffect(() => {
    const loadDescription = async () => {
      try {
        const desc = await descriptionStorage.getDescription(bookmark.id)
        setDescription(desc)
      } catch (error) {
        console.error("Failed to load description:", error)
      } finally {
        setIsLoadingDescription(false)
      }
    }
    
    if (bookmark.id) {
      loadDescription()
    }
  }, [bookmark.id])


  const handlePin = async (e: React.MouseEvent) => {
    e.stopPropagation()
    if (isPinning) return

    try {
      setIsPinning(true)
      if (isFolder) {
        await toggleFolderPin(bookmark.id)
      } else {
        await togglePin(bookmark.id)
      }
    } catch (error) {
      console.error('Error toggling pin:', error)
    } finally {
      setIsPinning(false)
    }
  }

  // 处理描述保存
  const handleSaveDescription = async (newDescription: string) => {
    try {
      await descriptionStorage.setDescription(bookmark.id, newDescription.trim())
      setDescription(newDescription.trim())
      setIsEditingDescription(false)
    } catch (error) {
      console.error("Failed to save description:", error)
    }
  }


  // 处理描述的编辑取消
  const handleCancelEdit = () => {
    setIsEditingDescription(false)
    setDescription(description) // 恢复原始描述
  }

  const isAddedToday = bookmark.dateAdded ? isToday(bookmark.dateAdded) : false;

  const handleClick = async (e: React.MouseEvent) => {
    if (isEditingDescription) {
      e.preventDefault()
      return
    }
    
    if (isFolder) {
      setIsExpanded(!isExpanded)
    } else if (bookmark.url) {
      // 记录访问
      try {
        await visitStorage.recordVisit(bookmark.id)
      } catch (error) {
        console.error("Failed to record visit:", error)
      }
      window.open(bookmark.url, '_blank')
    }
  }

  const handleDeleteClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    setShowDeleteConfirm(true)
    setCountdown(BOOKMARK_CONFIG.delete.confirmDuration)
    
    // 开始倒计时
    countdownRef.current = setInterval(() => {
      setCountdown(prev => {
        if (prev <= 1) {
          handleConfirmDelete(e)
          return 0
        }
        return prev - 1
      })
    }, 1000)
  }

  const handleConfirmDelete = async (e: React.MouseEvent) => {
    e.stopPropagation()
    clearInterval(countdownRef.current)
    try {
      setIsDeleting(true)
      
      // 如果是已固定的项目,先取消固定
      if (isItemPinned) {
        if (isFolder) {
          await pinService.unpinFolder(bookmark.id)
        } else {
          await pinService.unpinBookmark(bookmark.id)
        }
      }
      
      // 然后删除书签
      await bookmarkService.removeBookmark(bookmark.id)
      setIsRemoving(true)
      setTimeout(() => {
        itemRef.current?.remove()
      }, 200)
    } catch (error) {
      if (error.message === "Can't find bookmark for id.") {
        console.warn("Bookmark not found, assuming it was already deleted.")
        setIsRemoving(true)
        setTimeout(() => {
          itemRef.current?.remove()
        }, 200)
      } else {
        console.error('Error deleting bookmark:', error)
        setIsRemoving(false)
      }
    } finally {
      setIsDeleting(false)
      setShowDeleteConfirm(false)
    }
  }

  const handleCancelDelete = (e: React.MouseEvent) => {
    e.stopPropagation()
    clearInterval(countdownRef.current)
    setShowDeleteConfirm(false)
    setCountdown(BOOKMARK_CONFIG.delete.confirmDuration)
  }

  // 组件卸载时清理定时器
  useEffect(() => {
    return () => {
      clearInterval(countdownRef.current)
    }
  }, [])

  return (
    <div 
      ref={itemRef} 
      className={cn(
        "bookmark-item relative",
        "transition-all duration-200 ease-out",
        isRemoving && "transform -translate-x-full opacity-0"  // 向左滑动并淡出
      )}
    >
      <div className={cn(
        "px-1",
        level > 0 && "ml-2",
        className
      )}>
        {/* 卡片主体 */}
        <div
            onClick={handleClick}
            className={cn(
              "bookmark-group relative rounded-lg border",
              "transition-colors duration-100",
              "cursor-pointer overflow-hidden", 
              "flex items-center gap-2 p-2",
              isAddedToday ? [
                // 明亮模式
                "border-primary/10 bg-primary/5",
                "hover:border-primary/40 hover:bg-primary/10",
                // 深色模式
                "dark:border-[#2D2F36] dark:bg-[#202229]",  
                "dark:hover:border-[#2D2F36] dark:hover:bg-[#252832]"
              ] : [
                // 明亮模式
                "border-border bg-background",
                "hover:border-primary/30 hover:bg-muted/40",
                // 深色模式
                "dark:border-[#2D2F36] dark:bg-[#1A1C24]",
                "dark:hover:border-[#2D2F36] dark:hover:bg-[#202229]"
              ]
            )}
          >
          {/* 图标 */}
          <div className="flex-shrink-0 w-8 h-8">
            <BookmarkIcon
              url={bookmark.url}
              title={bookmark.title}
              isFolder={isFolder}
            />  
          </div>

          {/* 文本内容区域 */}
          <div className="flex flex-col min-w-0 flex-grow">
            {/* 标题行 */}
            <span className="text-sm truncate leading-5">
              {bookmark.title || "无标题"}
            </span>
            
            {/* 描述/URL行 */}
            {!isFolder && (
              <div className="flex items-center min-w-0">
                {isEditingDescription ? (
                  <div 
                    className="flex-grow relative"
                    onClick={e => e.stopPropagation()}
                  >
                   <Input
                      ref={descriptionInputRef}
                      value={description}
                      onChange={(e) => setDescription(e.target.value)}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                          handleSaveDescription(description)
                        } else if (e.key === 'Escape') {
                          handleCancelEdit()
                        }
                        e.stopPropagation()
                      }}
                      onBlur={() => handleSaveDescription(description)}
                      placeholder="添加描述, 方便搜索..."
                      className={cn(
                        "h-5 text-xs py-0 px-1",
                        "bg-background", 
                        "border-input hover:border-ring",
                        "focus:ring-ring focus:border-ring",
                        "placeholder:text-muted-foreground/50",
                        "transition-colors duration-200",
                        "rounded-[4px]"
                      )}
                      autoFocus
                    />
                  </div>
                ) : (
                  <span className="text-xs text-gray-400 truncate leading-5">
                    {description || displayUrl}
                  </span>
                )}
              </div>
            )}
          </div>

          {/* 操作按钮组 */}
          <div className="flex items-center gap-1 flex-shrink-0">
            {/* 描述编辑按钮 */}
            {!isFolder && (
              <EditButton
                description={description}
                onEdit={(e) => {
                  e.stopPropagation()
                  setIsEditingDescription(true)
                  setTimeout(() => {
                    descriptionInputRef.current?.focus()
                  }, 0)
                }}
              />
            )}

            {/* Pin 按钮 */}
            <PinButton
              isPinned={isItemPinned}
              isPinning={isPinning}
              isFolder={isFolder}
              onPin={handlePin}
            />

            {/* 文件夹展开指示器 */}
            {isFolder && bookmark.children?.length > 0 && (
              <div className="text-gray-400">
                <ChevronRight className={cn(
                  "h-4 w-4 transition-transform duration-200",
                  isExpanded && "transform rotate-90"
                )} />
              </div>
            )}

            {(!isFolder || (isFolder && (!bookmark.children || bookmark.children.length === 0))) && (
              <DeleteButton
                isFolder={isFolder}
                showConfirm={showDeleteConfirm}
                isDeleting={isDeleting}
                countdown={countdown}
                onDelete={handleDeleteClick}
                onConfirm={handleConfirmDelete}
                onCancel={handleCancelDelete}
              />
            )}
          </div>
        </div>

        {/* 子书签渲染 */}
        {isFolder && isExpanded && bookmark.children && (
          <div className="mt-1 space-y-1.5">
            {bookmark.children.map((child) => (
              <BookmarkItem
                key={child.id}
                bookmark={child}
                level={level + 1}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  )
}

export default BookmarkItem

================
File: src/components/bookmark/buttons/DeleteButton.tsx
================
import React from "react"
import { Trash2, X } from "lucide-react"
import { Button } from "~/components/ui/button"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "~/components/ui/tooltip"
import { cn } from "~/lib/utils"
import { BOOKMARK_CONFIG } from "~/config/bookmark"

interface DeleteButtonProps {
  isFolder: boolean
  showConfirm: boolean
  isDeleting: boolean
  countdown: number
  onDelete: (e: React.MouseEvent) => void
  onConfirm: (e: React.MouseEvent) => void
  onCancel: (e: React.MouseEvent) => void
}

export const DeleteButton: React.FC<DeleteButtonProps> = ({
  isFolder,
  showConfirm,
  isDeleting,
  countdown,
  onDelete,
  onConfirm,
  onCancel
}) => {
  // 计算倒计时进度百分比
  const progress = (countdown / BOOKMARK_CONFIG.delete.confirmDuration) * 100

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          {!showConfirm ? (
            <Button
              size="icon"
              variant="ghost"
              onClick={onDelete}
              className={cn(
                "h-8 w-8 p-0",
                "opacity-0 bookmark-group-hover:opacity-100",
                "focus:opacity-100",
                "hover:text-destructive",
              )}
            >
              <Trash2 className="h-4 w-4" />
              <span className="sr-only">
                删除{isFolder ? "文件夹" : "书签"}
              </span>
            </Button>
          ) : (
            <div className="relative flex items-center gap-1">
              {/* 确认按钮 */}
              <div className="relative">
                <Button
                  size="sm"
                  variant="ghost"
                  onClick={onConfirm}
                  className={cn(
                    "relative h-7 w-7",
                    "text-xs font-medium text-destructive",
                    "overflow-hidden",
                    "focus:opacity-100",
                    "dark:hover:bg-slate-800",
                    "transition-all duration-200",
                    isDeleting && "opacity-80"
                  )}
                  disabled={isDeleting}
                >
                  {/* 倒计时文字 */}
                  <span className={cn(
                    "relative z-10",
                    "transition-opacity duration-200",
                    isDeleting && "opacity-0"
                  )}>
                    {countdown}
                  </span>
                  
                  {/* 加载中状态 */}
                  {isDeleting && (
                    <div className="absolute inset-0 flex items-center justify-center">
                      <div className="w-4 h-0.5 bg-current rounded-full animate-pulse" />
                    </div>
                  )}
                </Button>

                {/* 环形进度条 */}
                <svg
                  className="absolute inset-0 w-full h-full -rotate-90"
                  viewBox="0 0 100 100"
                >
                  <circle
                    className="text-destructive/20"
                    cx="50"
                    cy="50"
                    r="45"
                    strokeWidth="6"
                    fill="none"
                    stroke="currentColor"
                  />
                  <circle
                    className="text-destructive transition-all duration-1000"
                    cx="50"
                    cy="50"
                    r="45"
                    strokeWidth="6"
                    fill="none"
                    stroke="currentColor"
                    strokeDasharray={`${2 * Math.PI * 45}`}
                    strokeDashoffset={`${2 * Math.PI * 45 * (1 - progress / 100)}`}
                  />
                </svg>
              </div>

              {/* 取消按钮 */}
              <Button
                size="sm"
                variant="ghost"
                onClick={onCancel}
                className={cn(
                  "h-7 w-7 p-0",
                  "hover:text-destructive",
                  "transition-colors duration-200",
                  isDeleting && "opacity-50"
                )}
                disabled={isDeleting}
              >
                <X className="h-3.5 w-3.5" />
              </Button>
            </div>
          )}
        </TooltipTrigger>
        {!showConfirm && (
          <TooltipContent side="top" className="text-xs">
            <p>删除{isFolder ? "文件夹" : "书签"}</p>
          </TooltipContent>
        )}
      </Tooltip>
    </TooltipProvider>
  )
}

================
File: src/components/bookmark/buttons/EditButton.tsx
================
import React from "react"
import { Edit2 } from "lucide-react"
import { Button } from "~/components/ui/button"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "~/components/ui/tooltip"
import { cn } from "~/lib/utils"

interface EditButtonProps {
  description: string
  onEdit: (e: React.MouseEvent) => void
}

export const EditButton: React.FC<EditButtonProps> = ({
  description,
  onEdit
}) => {
  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            size="icon"
            variant="ghost"
            onClick={onEdit}
            className={cn(
              "h-8 w-8 p-0",
            "opacity-0 bookmark-group-hover:opacity-100",
              "focus:opacity-100",
              "dark:hover:bg-slate-800"
            )}
          >
            <Edit2 
              className="h-4 w-4"
            />
            <span className="sr-only">
              {description ? "编辑描述" : "添加描述"}
            </span>
          </Button>
        </TooltipTrigger>
        <TooltipContent side="top" className="text-xs">
          <p>{description ? "编辑描述" : "添加描述"}</p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  )
}

================
File: src/components/bookmark/buttons/PinButton.tsx
================
import React from "react"
import { Pin } from "lucide-react"
import { Button } from "~/components/ui/button"
import { cn } from "~/lib/utils"

interface PinButtonProps {
  isPinned: boolean
  isPinning: boolean
  isFolder: boolean
  onPin: (e: React.MouseEvent) => void
}

export const PinButton: React.FC<PinButtonProps> = ({
  isPinned,
  isPinning,
  isFolder,
  onPin
}) => {
  return (
    <Button
      size="icon"
      variant="ghost"
      onClick={onPin}
      className={cn(
        "h-8 w-8 p-0",
        "opacity-0 bookmark-group-hover:opacity-100",
        "focus:opacity-100",
        isPinned && "opacity-100 text-blue-500",
        isPinning && "cursor-wait",
        "focus:opacity-100",
        "dark:hover:bg-slate-800"
      )}
      disabled={isPinning}
    >
      <Pin 
        className={cn(
          "h-4 w-4 transition-all",
          isPinned && "fill-current",
          isPinning && "animate-pulse"
        )} 
      />
      <span className="sr-only">
        {isPinned ? "取消固定" : "固定"} {isFolder ? "文件夹" : "书签"}
      </span>
    </Button>
  )
}

================
File: src/components/folder/CreateFolderDrawer.tsx
================
// src/components/folder/CreateFolderDrawer.tsx
import React from "react"
import { useForm } from "react-hook-form"
import { FolderPlus, Loader2 } from "lucide-react"
import { cn } from "~/lib/utils"
import { Button } from "~/components/ui/button"
import { Input } from "~/components/ui/input"
import { Label } from "~/components/ui/label"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select"
import {
  Drawer,
  DrawerClose,
  DrawerContent,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerTitle,
} from "~/components/ui/drawer"
import { bookmarkService } from "~/services/bookmarks"
import toast from 'react-hot-toast';
import type { BookmarkTreeNode } from "~/types/bookmark"
import { useSearch } from "~/contexts/SearchContext"
import { useTabs } from "~/contexts/TabContext"
import eventBus from "~/lib/events"

interface CreateFolderDrawerProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  onSuccess?: () => void
}

interface FormData {
  name: string
  parentId: string
}

export const CreateFolderDrawer: React.FC<CreateFolderDrawerProps> = ({
  open,
  onOpenChange,
  onSuccess
}) => {
  const { clearSearch } = useSearch()
  const { activeTab, setActiveTab } = useTabs()
  const [isSubmitting, setIsSubmitting] = React.useState(false)
  const [folders, setFolders] = React.useState<BookmarkTreeNode[]>([])

  const {
    register,
    handleSubmit,
    reset,
    setValue,
    watch,
    formState: { errors }
  } = useForm<FormData>({
    defaultValues: {
      name: "",
      parentId: "1" // 默认为书签栏
    }
  })

  // 加载文件夹列表
  const loadFolders = React.useCallback(async () => {
    try {
      const tree = await bookmarkService.getTree()
      const folderList: BookmarkTreeNode[] = []
      
      // 递归获取所有文件夹
      const extractFolders = (node: BookmarkTreeNode, level: number = 0) => {
        if (!node.url) { // 如果没有 url 属性,说明是文件夹
          // 为标题添加缩进标记
          node.title = "  ".repeat(level) + node.title
          folderList.push(node)
          node.children?.forEach(child => extractFolders(child, level + 1))
        }
      }

      // 添加书签栏作为根选项
      folderList.push({
        id: "1",
        title: "书签栏",
        children: []
      })
      
      // 处理书签树
      tree.forEach(node => extractFolders(node))
      
      setFolders(folderList)
    } catch (error) {
      console.error("Failed to load folders:", error)
      toast.error('创建失败');

    }
  }, [toast])

  // 当抽屉打开时加载文件夹列表
  React.useEffect(() => {
    if (open) {
      loadFolders()
    }
  }, [open, loadFolders])

  // 处理表单提交
  const onSubmit = async (data: FormData) => {
    try {
      setIsSubmitting(true)

      await bookmarkService.createBookmark({
        title: data.name.trim(),
        parentId: data.parentId
      })

      toast.success('创建成功！');

      // 重置表单、清除搜索并关闭抽屉
      reset()
      clearSearch() // 添加清除搜索
      onOpenChange(false)
      //onSuccess?.()
      if (activeTab === 'recent') {
        // 如果已经在 recent 页面，发送刷新事件
        eventBus.emit('REFRESH_RECENT')
      } else {
        // 否则切换到 recent 页面
        await setActiveTab('recent')
      }

    } catch (error) {
      console.error("Failed to create folder:", error)
      toast.error('创建失败');

    } finally {
      setIsSubmitting(false)
    }
  }


  // 处理抽屉关闭
  const handleOpenChange = (open: boolean) => {
    if (!open) {
      reset() // 重置表单
      clearSearch() // 清除搜索
    }
    onOpenChange(open)
  }

  // 监听父文件夹选择
  const parentId = watch("parentId")

  return (
    <Drawer open={open} onOpenChange={handleOpenChange}>
      <DrawerContent className="max-h-[85vh]"> {/* 调整最大高度 */}
        <form onSubmit={handleSubmit(onSubmit)}>
          <DrawerHeader className="py-3"> {/* 减小头部内边距 */}
            <DrawerTitle className="text-base flex items-center gap-1.5"> {/* 减小标题字体 */}
              <FolderPlus className="h-4 w-4" /> {/* 减小图标尺寸 */}
              创建一个新的书签文件夹
            </DrawerTitle>
            <DrawerDescription className="text-xs text-muted-foreground"></DrawerDescription>
          </DrawerHeader>

          <div className="px-4 py-2 space-y-3"> {/* 减小内容区域间距 */}
            {/* 文件夹名称 */}
            <div className="space-y-1.5"> {/* 减小表单项间距 */}
              <Label htmlFor="name" className="text-sm"> {/* 减小标签字体 */}
                文件夹名称
                <span className="text-destructive ml-1">*</span>
              </Label>
              <Input
                id="name"
                autoFocus
                {...register("name", {
                  required: "请输入文件���名称",
                  maxLength: {
                    value: 50,
                    message: "文件夹名称不能超过50个字符"
                  },
                  pattern: {
                    value: /^[^<>:"/\\|?*]+$/,
                    message: "文件夹名称不能包含特殊字符 < > : \" / \\ | ? *"
                  }
                })}
                className={cn(
                  "h-9", // 调整输入框高度
                  "bg-background", // 添加背景色
                  "ring-offset-background", 
                  "border-border",
                  "hover:border-primary/30",
                  "dark:border-[#2D2F36]",
                  "dark:hover:border-[#2D2F36]",
                  "placeholder:text-muted-foreground",
                  "focus-visible:ring-ring",
                  errors.name && [
                    "border-destructive",
                    "focus-visible:ring-destructive"
                  ]
                )}
              />
              {errors.name && (
                <p className="text-xs text-destructive mt-1"> {/* 减小错误提示字体和间距 */}
                  {errors.name.message}
                </p>
              )}
            </div>

            {/* 父文件夹选择 */}
            <div className="space-y-1.5"> {/* 减小表单项间距 */}
              <Label className="text-sm"> {/* 减小标签字体 */}
                选择位置
                <span className="text-destructive ml-1">*</span>
              </Label>
              <Select
                value={parentId}
                onValueChange={(value) => setValue("parentId", value)}
              >
                <SelectTrigger className="h-9 bg-background border-border ring-offset-background hover:ring-offset-0 dark:border-[#2D2F36] dark:hover:border-[#2D2F36]"> {/* 调整选择器样式 */}
                  <SelectValue placeholder="选择文件夹位置" />
                </SelectTrigger>
                <SelectContent>
                  {folders.map((folder) => (
                    <SelectItem
                      key={folder.id} 
                      value={folder.id}
                      className="whitespace-pre text-sm" // 减小选项字体
                    >
                      {folder.title}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          <DrawerFooter className="p-4 pt-2"> {/* 减小页脚内边距 */}
            <div className="flex flex-col gap-2"> {/* 使用 flex 布局调整按钮间距 */}
              <Button
                type="submit"
                disabled={isSubmitting}
                className={cn(
                  "h-9", // 调整按钮高度
                  "bg-primary hover:bg-primary/90", // 使用主题色
                  "text-primary-foreground",
                  "flex items-center justify-center gap-1.5"
                )}
              >
                {isSubmitting ? (
                  <>
                    <Loader2 className="h-3 w-3 animate-spin" />
                    创建中...
                  </>
                ) : (
                  <>
                    <FolderPlus className="h-3 w-3" />
                    创建文件夹
                  </>
                )}
              </Button>
              <DrawerClose asChild>
                <Button 
                  variant="outline" 
                  className="h-9" // 调整按钮高度
                >
                  取消
                </Button>
              </DrawerClose>
            </div>
          </DrawerFooter>
        </form>
      </DrawerContent>
    </Drawer>
  )
}

================
File: src/components/views/BaseView.tsx
================
// src/components/views/BaseView.tsx
import React from "react"
import { Card, CardContent } from "../ui/card"
import ViewHeader from "../ViewHeader"
import BookmarkList from "../bookmark/BookmarkList"
import { useSearch } from "~/contexts/SearchContext"
import { cn } from "~/lib/utils"
import type { TabType } from "~/types/tab"
import type { BookmarkTreeNode } from "~/types/bookmark"

interface BaseViewProps {
  activeTab: TabType
  loading: boolean
  error: string | null
  bookmarks: BookmarkTreeNode[]
  header?: React.ReactNode
}

const BaseView: React.FC<BaseViewProps> = ({
  activeTab,
  loading,
  error,
  bookmarks,
  header
}) => {
  const { isSearching, searchTerm, error: searchError } = useSearch()

  // 确定实际显示状态
  const showLoading = loading || isSearching
  const showError = error || searchError
  const isEmpty = !showLoading && !showError && bookmarks.length === 0

  return (
    <Card className="w-full border-none shadow-none bg-transparent flex-1">
      {/* 搜索头部 */}
      <ViewHeader activeTab={activeTab} />
      
      {/* 内容区域 */}
      <CardContent className={cn(
        "p-0 flex-1",
        "min-h-[calc(100vh-180px)]" // 确保最小高度
      )}>
        {/* 自定义头部内容 */}
        {header}

        {/* 内容容器 */}
        <div className={cn(
          "h-full",
          isEmpty && "flex items-center justify-center" // 空状态时居中显示
        )}>
          {/* 加载状态 */}
          {showLoading && (
            <div className="flex items-center justify-center p-4">
              <div className="text-muted-foreground animate-spin mr-2">
                {/* 可以添加一个加载图标 */}
              </div>
              <span className="text-muted-foreground">加载中...</span>
            </div>
          )}

          {/* 错误状态 */}
          {showError && (
            <div className="flex items-center justify-center p-4 text-destructive">
              {showError}
            </div>
          )}

          {/* 空状态 */}
          {isEmpty && (
            <div className="text-center p-4">
              <div className="text-muted-foreground">
                {searchTerm ? "未找到匹配的书签" : getEmptyStateMessage(activeTab)}
              </div>
            </div>
          )}

          {/* 书签列表 */}
          {!showLoading && !showError && bookmarks.length > 0 && (
            <div className={cn(
              "h-[calc(100vh-120px)]", 
              "overflow-y-auto",
              "custom-scrollbar"
            )}>
              <BookmarkList 
                bookmarks={bookmarks}
                className="pb-16" // 底部留出空间避免被底部导航遮挡
              />
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  )
}

// 获取空状态消息
const getEmptyStateMessage = (activeTab: TabType): string => {
  switch (activeTab) {
    case 'pinned':
      return '暂无固定书签\n可以通过点击书签右侧的图钉图标来固定书签'
    case 'hot':
      return '暂无热门书签\n访问书签后这里会显示最常访问的书签'
    case 'tag':
      return '暂无标签\n点击右下角的按钮创建新标签'
    case 'recent':
      return '暂无最近书签'
    default:
      return '暂无书签'
  }
}

export default BaseView

================
File: src/components/views/RecentView.tsx
================
// src/components/views/RecentView.tsx
import React, { useState, useEffect, useCallback } from "react"
import BaseView from "./BaseView"
import { useSearch } from "~/contexts/SearchContext"
import { bookmarkService } from "~/services/bookmarks"
import type { TabType } from "~/types/tab"
import type { BookmarkTreeNode } from "~/types/bookmark"
import eventBus from "~/lib/events"

interface RecentViewProps {
  activeTab: TabType
}

const RecentView: React.FC<RecentViewProps> = ({ activeTab }) => {
  const { searchTerm, searchResults } = useSearch()
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [bookmarks, setBookmarks] = useState<BookmarkTreeNode[]>([])

  // 加载最近书签
  const loadRecentBookmarks = useCallback(async () => {
    if (searchTerm) return
    
    try {
      setLoading(true)
      setError(null)
      const recentBookmarks = await bookmarkService.getRecent(20)
      setBookmarks(recentBookmarks)
    } catch (err) {
      console.error("Failed to load recent bookmarks:", err)
      setError("加载最近书签失败")
    } finally {
      setLoading(false)
    }
  }, [searchTerm])

  // 监听活动标签和搜索状态变化
  useEffect(() => {
    if (activeTab === "recent") {
      loadRecentBookmarks()
    }
  }, [activeTab, loadRecentBookmarks])

  useEffect(() => {
    // 监听刷新事件
    const refresh = () => {
      loadRecentBookmarks()
    }
    
    eventBus.on('REFRESH_RECENT', refresh)
    
    return () => {
      eventBus.off('REFRESH_RECENT', refresh)
    }
  }, [])


  // 如果没有搜索词但书签列表为空，尝试加载数据
  useEffect(() => {
    if (!searchTerm && bookmarks.length === 0 && activeTab === "recent") {
      loadRecentBookmarks()
    }
  }, [searchTerm, bookmarks.length, activeTab, loadRecentBookmarks])

  const displayBookmarks = searchTerm ? searchResults : bookmarks

  return (
    <BaseView
      activeTab={activeTab}
      loading={loading}
      error={error}
      bookmarks={displayBookmarks}
    />
  )
}

export default RecentView

================
File: src/components/views/HotView.tsx
================
import React, { useState, useEffect } from "react"
import { Eraser } from "lucide-react"
import BaseView from "./BaseView"
import { useSearch } from "~/contexts/SearchContext"
import { visitStorage } from "~/services/storage/visit"
import { bookmarkService } from "~/services/bookmarks"
import { Button } from "~/components/ui/button"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "~/components/ui/tooltip"
import { cn } from "~/lib/utils"
import type { TabType } from "~/types/tab"
import type { BookmarkTreeNode } from "~/types/bookmark"

interface HotViewProps {
  activeTab: TabType
}

const HotView: React.FC<HotViewProps> = ({ activeTab }) => {
  const { searchTerm, searchResults } = useSearch()
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [bookmarks, setBookmarks] = useState<BookmarkTreeNode[]>([])
  const [isClearing, setIsClearing] = useState(false)
  const [showClearConfirm, setShowClearConfirm] = useState(false)
  const [isRippling, setIsRippling] = useState(false)

  const loadHotBookmarks = async () => {
    if (searchTerm) return
    
    try {
      setLoading(true)
      setError(null)
      
      const hotVisits = await visitStorage.getHotBookmarks(20)
      const hotBookmarks = await Promise.all(
        hotVisits.map(async visit => {
          try {
            const bookmark = await bookmarkService.getBookmark(visit.id)
            return {
              ...bookmark,
              visitCount: visit.count
            }
          } catch {
            return null
          }
        })
      )
      
      setBookmarks(hotBookmarks.filter((b): b is { visitCount: number } & BookmarkTreeNode => b !== null))
    } catch (err) {
      console.error("Failed to load hot bookmarks:", err)
      setError("加载热门书签失败") 
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    if (activeTab === "hot") {
      loadHotBookmarks()
    }
  }, [activeTab])

  // 处理清除按钮点击
  const handleClearClick = () => {
    setIsRippling(true)
    setShowClearConfirm(true)
    setTimeout(() => setIsRippling(false), 200)
  }

  // 处理确认清除
  const handleConfirmClear = async () => {
    try {
      setIsClearing(true)
      await visitStorage.clearVisits()
      setBookmarks([])
      setShowClearConfirm(false)
    } catch (error) {
      console.error("Failed to clear hot records:", error)
      setError("清除热门记录失败")
    } finally {
      setIsClearing(false)
    }
  }

  const displayBookmarks = searchTerm ? searchResults : bookmarks

  return (
    <>
      <BaseView
        activeTab={activeTab}
        loading={loading}
        error={error}
        bookmarks={displayBookmarks}
      />

      {/* 清除按钮 */}
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              size="icon"
              className={cn(
                "fixed right-4 bottom-20",
                "h-10 w-10 rounded-full",
                "shadow-lg hover:shadow-xl",
                "bg-background border border-border",
                "hover:bg-muted",
                "transition-all duration-200",
                "flex items-center justify-center",
                "float-animation",
                isRippling && "animate-pulse",
                showClearConfirm && "hidden"
              )}
              variant="outline"
              onClick={handleClearClick}
              disabled={isClearing || bookmarks.length === 0}
            >
              <Eraser className="h-5 w-5 text-muted-foreground" />
              <span className="sr-only">清除热门记录</span>
            </Button>
          </TooltipTrigger>
          <TooltipContent side="left" className="select-none">
            <p>清除热门记录</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>

      {/* 确认对话框 */}
      {showClearConfirm && (
        <div className={cn(
          "fixed right-4 bottom-20",
          "flex items-center gap-2",
          "p-3 rounded-lg",
          "bg-muted border border-border",
          "shadow-lg",
          "animate-in fade-in-0 slide-in-from-right-5"
        )}>
          <span className="text-sm text-foreground">确定要清除所有热门记录吗？</span>
          <div className="flex items-center gap-2">
            <Button
              size="sm"
              variant="secondary"
              className="h-7"
              onClick={handleConfirmClear}
              disabled={isClearing}
            >
              {isClearing ? "清除中..." : "确定"}
            </Button>
            <Button
              size="sm"
              variant="ghost"
              className="h-7"
              onClick={() => setShowClearConfirm(false)}
              disabled={isClearing}
            >
              取消
            </Button>
          </div>
        </div>
      )}
    </>
  )
}

export default HotView

================
File: src/components/views/PinView.tsx
================
// src/components/views/PinView.tsx
import React, { useState, useEffect } from "react"
import BaseView from "./BaseView"
import { useSearch } from "~/contexts/SearchContext"
import { usePinned } from "~/contexts/PinnedContext"
import type { TabType } from "~/types/tab"

interface PinViewProps {
  activeTab: TabType
}

const PinView: React.FC<PinViewProps> = ({ activeTab }) => {
  const { searchTerm, searchResults } = useSearch()
  const { pinnedBookmarks, pinnedFolders, refreshPinnedItems } = usePinned()
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // 加载固定书签
  const loadPinnedItems = async () => {
    if (searchTerm) return // 如果有搜索词，不加载数据
    
    try {
      setLoading(true)
      setError(null)
      await refreshPinnedItems()
    } catch (err) {
      console.error("Failed to load pinned items:", err)
      setError("加载固定项目失败")
    } finally {
      setLoading(false)
    }
  }

  // 当活动标签改变时重新加载
  useEffect(() => {
    loadPinnedItems()
  }, [activeTab])

  // 根据搜索状态决定显示内容
  const displayBookmarks = searchTerm 
    ? searchResults 
    : [...pinnedFolders, ...pinnedBookmarks]

  return (
    <BaseView
      activeTab={activeTab}
      loading={loading}
      error={error}
      bookmarks={displayBookmarks}
    />
  )
}

export default PinView

================
File: src/components/views/TagView.tsx
================
// src/components/views/TagView.tsx
import React, { useState, useEffect, useCallback } from "react"
import { Plus } from "lucide-react"
import BaseView from "./BaseView"
import TagList from "../tag/TagList"
import TagForm from "../tag/form/TagForm"
import { useSearch } from "~/contexts/SearchContext"
import { tagStorage } from "~/services/storage"
import { tagService } from "~/services/bookmarks"
import { Button } from "../ui/button"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "../ui/tooltip"
import { cn } from "~/lib/utils"
import { AnimatePresence } from "framer-motion"
import type { Tag } from "~/types/tag"
import type { TabType } from "~/types/tab"
import type { BookmarkTreeNode } from "~/types/bookmark"

interface TagViewProps {
  activeTab: TabType
}

export const TagView: React.FC<TagViewProps> = ({ activeTab }) => {
  // 获取搜索上下文
  const { searchTerm, searchResults, clearSearch } = useSearch()
  
  // 状态管理
  const [tags, setTags] = useState<Tag[]>([])
  const [showCreateForm, setShowCreateForm] = useState(false)
  const [isRippling, setIsRippling] = useState(false)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [isSaving, setIsSaving] = useState(false)
  const [selectedTag, setSelectedTag] = useState<Tag | null>(null)
  const [matchedBookmarks, setMatchedBookmarks] = useState<BookmarkTreeNode[]>([])

  // 加载标签数据
  const loadTags = async () => {
    try {
      setLoading(true)
      setError(null)
      await tagStorage.initialize()
      const loadedTags = await tagStorage.getAllTags()
      setTags(loadedTags)
    } catch (error) {
      console.error('Failed to load tags:', error)
      setError('加载标签失败')
    } finally {
      setLoading(false)
    }
  }

  // 当活动标签改变时重新加载
  useEffect(() => {
    if (activeTab === 'tag') {
      loadTags()
    }
  }, [activeTab])

  // 处理标签选择
  const handleTagSelect = useCallback(async (tag: Tag) => {
    try {
      // 清除搜索状态
      clearSearch()
      
      setSelectedTag(tag)
      setLoading(true)
      const matches = await tagService.searchByTag(tag.conditions)
      setMatchedBookmarks(matches)
    } catch (error) {
      console.error('Failed to match bookmarks:', error)
      setMatchedBookmarks([])
      setError('加载标签匹配结果失败')
    } finally {
      setLoading(false)
    }
  }, [clearSearch])

  // 当切换到标签页面时，确保清除搜索状态
  useEffect(() => {
    if (activeTab === 'tag' && selectedTag) {
      clearSearch()
    }
  }, [activeTab, selectedTag, clearSearch])

  // 处理标签删除
  const handleTagDelete = async (tag: Tag) => {
    try {
      await tagStorage.deleteTag(tag.id)
      setTags(prevTags => prevTags.filter(t => t.id !== tag.id))
      
      // 如果删除的是当前选中的标签，清除选中状态和匹配结果
      if (selectedTag?.id === tag.id) {
        setSelectedTag(null)
        setMatchedBookmarks([])
      }
    } catch (error) {
      console.error('Failed to delete tag:', error)
      setError('删除标签失败')
    }
  }

  // 处理标签创建/更新
  const handleTagSubmit = async (tagData: Omit<Tag, "id" | "createdAt" | "updatedAt" | "version">) => {
    setIsSaving(true)
    try {
      // 检查是否存在同名标签
      const existingTags = await tagStorage.getAllTags()
      const existingTag = existingTags.find(tag => 
        tag.name.toLowerCase() === tagData.name.toLowerCase() &&
        (!selectedTag || tag.id !== selectedTag.id)
      )

      if (existingTag) {
        // 如果存在同名标签，直接更新该标签
        const updatedTag = await tagStorage.updateTag(existingTag.id, tagData)
        setTags(prevTags => 
          prevTags.map(t => t.id === existingTag.id ? updatedTag : t)
        )
        
        // 更新匹配的书签
        const matches = await tagService.searchByTag(updatedTag.conditions)
        setMatchedBookmarks(matches)
      } else if (selectedTag) {
        // 更新现有标签
        const updatedTag = await tagStorage.updateTag(selectedTag.id, tagData)
        setTags(prevTags => 
          prevTags.map(t => t.id === selectedTag.id ? updatedTag : t)
        )
        
        // 更新匹配的书签
        const matches = await tagService.searchByTag(updatedTag.conditions)
        setMatchedBookmarks(matches)
      } else {
        // 创建新标签
        const newTag = await tagStorage.createTag(tagData)
        setTags(prevTags => [...prevTags, newTag])
      }
      
      // 关闭表单
      setShowCreateForm(false)
    } catch (error) {
      console.error('Failed to save tag:', error)
      setError('保存标签失败')
    } finally {
      setIsSaving(false)
    }
  }

  // 处理创建按钮点击
  const handleCreateClick = () => {
    setIsRippling(true)
    setSelectedTag(null) // 清除选中的标签
    setShowCreateForm(true)
    setTimeout(() => setIsRippling(false), 200)
  }

  // 根据状态决定显示的书签
  const displayBookmarks = searchTerm ? searchResults : matchedBookmarks

  return (
    <>
      <BaseView
        activeTab={activeTab}
        loading={loading}
        error={error}
        bookmarks={displayBookmarks}
        header={
          <div className="p-4">
            <TagList
              tags={tags}
              selectedTag={selectedTag}
              onSelect={handleTagSelect}
              onDelete={handleTagDelete}
            />
           
          </div>
        }
      />

      {/* 新建标签按钮 */}
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              size="icon"
              className={cn(
                "fixed right-4 bottom-20",
                "h-10 w-10 rounded-full",
                "shadow-lg hover:shadow-xl",
                "bg-primary text-primary-foreground",
                "hover:bg-primary/90",
                "transition-all duration-200",
                "flex items-center justify-center",
                "float-animation",
                isRippling && "animate-pulse"
              )}
              onClick={handleCreateClick}
              disabled={isSaving}
            >
              <Plus className="h-6 w-6" />
              <span className="sr-only">新建标签</span>
            </Button>
          </TooltipTrigger>
          <TooltipContent side="left" className="select-none">
            <p>新建标签</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>

      {/* 标签表单 */}
      <AnimatePresence>
        {showCreateForm && (
          <TagForm
            onClose={() => {
              setShowCreateForm(false)
              setSelectedTag(null)
            }}
            onSubmit={handleTagSubmit}
            editingTag={selectedTag}
            isSubmitting={isSaving}
          />
        )}
      </AnimatePresence>
    </>
  )
}

export default TagView

================
File: src/components/views/AllView.tsx
================
// src/components/views/AllView.tsx
import React, { useState, useEffect } from "react"
import BaseView from "./BaseView"
import { useSearch } from "~/contexts/SearchContext"
import { bookmarkService } from "~/services/bookmarks"
import type { TabType } from "~/types/tab"
import type { BookmarkTreeNode } from "~/types/bookmark"

interface AllViewProps {
  activeTab: TabType
}

const AllView: React.FC<AllViewProps> = ({ activeTab }) => {
  const { searchTerm, searchResults } = useSearch()
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [bookmarks, setBookmarks] = useState<BookmarkTreeNode[]>([])

  // 加载书签数据
  const loadBookmarks = async () => {
    if (searchTerm) return // 如果有搜索词，不加载数据
    
    try {
      setLoading(true)
      setError(null)
      const tree = await bookmarkService.getTree()
      setBookmarks(tree)
    } catch (err) {
      console.error("Failed to load bookmarks:", err)
      setError("加载书签失败")
    } finally {
      setLoading(false)
    }
  }

  // 当活动标签改变时重新加载
  useEffect(() => {
    loadBookmarks()
  }, [activeTab])

  // 根据搜索状态决定显示内容
  const displayBookmarks = searchTerm ? searchResults : bookmarks

  return (
    <BaseView
      activeTab={activeTab}
      loading={loading}
      error={error}
      bookmarks={displayBookmarks}
    />
  )
}

export default AllView

================
File: src/components/tag/TagList.tsx
================
import React, { useState } from "react"
import { X, Trash2, Check } from "lucide-react"
import { cn } from "~/lib/utils"

interface Tag {
  id: string
  name: string
  conditions: {
    urlKeywords?: string[]
    titleKeywords?: string[]
  }
}

interface TagListProps {
  tags: Tag[]
  selectedTag?: Tag | null
  onSelect: (tag: Tag) => void
  onDelete: (tag: Tag) => void
}

const TagList: React.FC<TagListProps> = ({
  tags,
  selectedTag,
  onSelect,
  onDelete
}) => {
  // 跟踪正在确认删除的tag id
  const [confirmingId, setConfirmingId] = useState<string | null>(null)

  // 处理删除确认
  const handleDeleteClick = (e: React.MouseEvent, tag: Tag) => {
    e.stopPropagation()
    if (confirmingId === tag.id) {
      onDelete(tag)
      setConfirmingId(null)
    } else {
      setConfirmingId(tag.id)
      // 自动取消确认状态
      setTimeout(() => {
        setConfirmingId(null)
      }, 3000) // 3秒后自动取消确认状态
    }
  }

  // 取消删除确认
  const handleCancelDelete = (e: React.MouseEvent) => {
    e.stopPropagation()
    setConfirmingId(null)
  }

  // 处理键盘事件
  const handleKeyDown = (e: React.KeyboardEvent, tag: Tag) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault()
      if (confirmingId === tag.id) {
        onDelete(tag)
        setConfirmingId(null)
      }
    } else if (e.key === 'Escape') {
      setConfirmingId(null)
    }
  }

  if (tags.length === 0) {
    return (
      <div className="text-center text-muted-foreground py-2">
        还没有创建任何Tag
      </div>
    )
  }

  return (
    <div className="flex flex-wrap gap-2">
      {tags.map((tag) => {
        const isConfirming = confirmingId === tag.id
        return (
          <div
            key={tag.id}
            className={cn(
              "group flex items-center gap-1 px-3 py-1 rounded-md",
              "text-sm font-medium cursor-pointer transition-all duration-200",
              "border border-transparent",
              getTagColor(tag.id),
              selectedTag?.id === tag.id && "ring-1 ring-offset-0",
              "hover:shadow-sm"
            )}
            onClick={() => onSelect(tag)}
            tabIndex={0}
            role="button"
            onKeyDown={(e) => handleKeyDown(e, tag)}
          >
            <span className="truncate max-w-[150px]">{tag.name}</span>
            
            {/* 删除按钮区域 */}
            <div className="flex items-center gap-0.5 ml-1">
              {isConfirming ? (
                <>
                  {/* 确认删除状态 */}
                  <button
                    onClick={(e) => handleDeleteClick(e, tag)}
                    className={cn(
                      "p-1 rounded-full",
                      "text-green-600 hover:text-green-700",
                      "transition-colors"
                    )}
                    title="确认删除"
                  >
                    <Check className="h-3 w-3" />
                  </button>
                  <button
                    onClick={handleCancelDelete}
                    className={cn(
                      "p-1 rounded-full",
                      "text-gray-500 hover:text-gray-700",
                      "transition-colors"
                    )}
                    title="取消"
                  >
                    <X className="h-3 w-3" />
                  </button>
                </>
              ) : (
                /* 普通状态的删除按钮 */
                <button
                  onClick={(e) => handleDeleteClick(e, tag)}
                  className={cn(
                    "opacity-0 group-hover:opacity-100",
                    "p-1 rounded-full",
                    "text-gray-500 hover:text-red-600",
                    "transition-all duration-200"
                  )}
                  title="删除标签"
                >
                  <Trash2 className="h-3 w-3" />
                </button>
              )}
            </div>
          </div>
        )
      })}
    </div>
  )
}

const getTagColor = (id: string) => {
  const TAG_COLORS = [
    // 使用微妙的渐变和半透明效果
    'bg-gradient-to-r from-blue-500/10 to-blue-500/5 text-blue-500/90 border border-blue-500/20 hover:bg-blue-500/[0.15] dark:from-blue-400/10 dark:to-blue-400/5 dark:text-blue-400 dark:border-blue-400/20 dark:hover:bg-blue-400/[0.15]',
    
    'bg-gradient-to-r from-green-500/10 to-green-500/5 text-green-500/90 border border-green-500/20 hover:bg-green-500/[0.15] dark:from-green-400/10 dark:to-green-400/5 dark:text-green-400 dark:border-green-400/20 dark:hover:bg-green-400/[0.15]',
    
    'bg-gradient-to-r from-purple-500/10 to-purple-500/5 text-purple-500/90 border border-purple-500/20 hover:bg-purple-500/[0.15] dark:from-purple-400/10 dark:to-purple-400/5 dark:text-purple-400 dark:border-purple-400/20 dark:hover:bg-purple-400/[0.15]',
    
    'bg-gradient-to-r from-amber-500/10 to-amber-500/5 text-amber-500/90 border border-amber-500/20 hover:bg-amber-500/[0.15] dark:from-amber-400/10 dark:to-amber-400/5 dark:text-amber-400 dark:border-amber-400/20 dark:hover:bg-amber-400/[0.15]',
    
    'bg-gradient-to-r from-rose-500/10 to-rose-500/5 text-rose-500/90 border border-rose-500/20 hover:bg-rose-500/[0.15] dark:from-rose-400/10 dark:to-rose-400/5 dark:text-rose-400 dark:border-rose-400/20 dark:hover:bg-rose-400/[0.15]',
    
    'bg-gradient-to-r from-cyan-500/10 to-cyan-500/5 text-cyan-500/90 border border-cyan-500/20 hover:bg-cyan-500/[0.15] dark:from-cyan-400/10 dark:to-cyan-400/5 dark:text-cyan-400 dark:border-cyan-400/20 dark:hover:bg-cyan-400/[0.15]'
  ]

  const index = Math.abs(id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0))
  return TAG_COLORS[index % TAG_COLORS.length]
}

export default TagList

================
File: src/components/tag/form/TagTemplatePreview.tsx
================
// src/components/tag/form/TagTemplatePreview.tsx
import React from "react"
import { cn } from "~/lib/utils"
import type { TagTemplate } from "~/types/tag"

interface TagTemplatePreviewProps {
  template: TagTemplate | null
  className?: string
}

export const TagTemplatePreview: React.FC<TagTemplatePreviewProps> = ({
  template,
  className
}) => {
  if (!template) return null

  return (
    <div className={cn(
      "space-y-1.5", // 减小间距
      className
    )}>
      <div className="flex items-center gap-1.5">
        {template.icon && <template.icon className="h-4 w-4" />}
        <h3 className="text-sm font-medium">{template.name}</h3>
      </div>
      
      {template.description && (
        <p className="text-xs text-muted-foreground">
          {template.description}
        </p>
      )}
      
      <div className="space-y-1 text-xs">
        {template.conditions.urlKeywords.length > 0 && (
          <div>
            <span className="text-muted-foreground">URL关键词: </span>
            {template.conditions.urlKeywords.join(", ")}
          </div>
        )}
        
        {template.conditions.titleKeywords.length > 0 && (
          <div>
            <span className="text-muted-foreground">标题关键词: </span>
            {template.conditions.titleKeywords.join(", ")}
          </div>
        )}
      </div>
    </div>
  )
}

================
File: src/components/tag/form/TagTemplates.tsx
================
// src/components/tag/form/TagTemplates.tsx
import React, { useState, useEffect } from "react"
import { motion } from "framer-motion"
import { cn } from "~/lib/utils"
import { templateService } from "~/services/bookmarks/template"
import type { TagTemplate } from "~/types/tag"

interface TagTemplatesProps {
  onSelect: (template: TagTemplate) => void
  className?: string
}

export const TagTemplates: React.FC<TagTemplatesProps> = ({
  onSelect,
  className
}) => {
  const [templates, setTemplates] = useState<TagTemplate[]>([])
  const [loading, setLoading] = useState(true)
  
  useEffect(() => {
    const loadTemplates = async () => {
      try {
        const generatedTemplates = await templateService.generateTemplates()
        setTemplates(generatedTemplates)
      } catch (error) {
        console.error('Failed to generate templates:', error)
      } finally {
        setLoading(false)
      }
    }
    
    loadTemplates()
  }, [])

  if (loading) {
    return <div className="text-sm text-muted-foreground">加载推荐模板中...</div>
  }

  return (
    <div className={cn(
      "flex flex-wrap gap-1.5",
      "custom-scrollbar",
      className
    )}>
      {templates.map((template) => {
        const Icon = template.icon
        
        return (
          <motion.button
            key={template.id}
            onClick={() => onSelect(template)}
            whileHover={{ scale: 1.03 }} // 减小悬停效果
            whileTap={{ scale: 0.97 }}
            className={cn(
              "flex items-center gap-1.5", // 减小间距
              "px-2 py-1", // 减小内边距
              "rounded-md",
              "text-xs font-medium", // 减小字体
              "bg-muted/50 hover:bg-muted",
              "border border-border/50",
              "transition-colors duration-200"
            )}
          >
            {Icon && <Icon className="h-3.5 w-3.5" />} {/* 减小图标尺寸 */}
            <span>{template.name}</span>
          </motion.button>
        )}
      )}
    </div>
  )
}

================
File: src/components/tag/form/ActionButtons.tsx
================
// src/components/tag/ActionButtons.tsx
import React from "react"
import { Button } from "~/components/ui/button"
import { Loader2, Undo, ArrowRight, X, Check } from "lucide-react"
import { cn } from "~/lib/utils"

type Step = 'name' | 'urlKeywords' | 'titleKeywords' | 'confirm'

interface ActionButtonsProps {
  currentStep: Step
  isSubmitting: boolean
  onSkip: () => void
  onConfirm: () => void
  onCancel: () => void
  onRestart: () => void
  disableSkip?: boolean
  isUsingTemplate: boolean
}

export const ActionButtons: React.FC<ActionButtonsProps> = ({
  currentStep,
  isSubmitting,
  onSkip,
  onConfirm,
  onCancel,
  onRestart,
  disableSkip = false,
  isUsingTemplate
}) => {
  // 第一步不显示按钮
  if (currentStep === 'name' || isSubmitting) return null

  // 确认步骤的按钮组
  if (currentStep === 'confirm') {
    return (
      <div className="px-4 py-2 flex items-center justify-between border-b border-border/40">
        {/* 左侧按钮组 */}
        <div className="flex items-center gap-2">
          <Button
            variant="ghost"
            size="sm"
            className={cn(
              "h-8",
              "text-xs text-muted-foreground hover:text-foreground",
              "transition-colors"
            )}
            onClick={onRestart}
          >
            <Undo className="h-3 w-3 mr-1" />
            重新开始
          </Button>
          <Button
            variant="ghost"
            size="sm"
            className={cn(
              "h-8",
              "text-xs text-muted-foreground hover:text-foreground",
              "transition-colors"
            )}
            onClick={onCancel}
          >
            <X className="h-3 w-3 mr-1" />
            取消
          </Button>
        </div>

        {/* 确认按钮 */}
        <Button
          size="sm"
          className={cn(
            "h-8",
            "bg-blue-500 hover:bg-blue-600 text-white",
            "text-xs font-medium",
            "transition-all duration-200",
            "flex items-center"
          )}
          onClick={onConfirm}
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <>
              <Loader2 className="mr-1.5 h-3 w-3 animate-spin" />
              创建中...
            </>
          ) : (
            <>
              <Check className="mr-1.5 h-3 w-3" />
              {isUsingTemplate ? "确认创建" : "创建标签"}
            </>
          )}
        </Button>
      </div>
    )
  }

  // 获取跳过按钮的文本和提示
  const getSkipButtonInfo = (step: Step): { text: string; tooltip?: string } => {
    switch (step) {
      case 'urlKeywords':
        return {
          text: '跳过网址关键词',
          tooltip: '如果跳过，则必须设置标题关键词'
        }
      case 'titleKeywords':
        return {
          text: '跳过标题关键词',
          tooltip: disableSkip ? '已跳过URL关键词，必须设置标题关键词' : undefined
        }
      default:
        return { text: '跳过此步骤' }
    }
  }

  // 其他步骤的按钮组
  const skipInfo = getSkipButtonInfo(currentStep)
  
  return (
    <div className="px-4 py-2 flex items-center justify-between border-b border-border/40">
      {/* 重新开始按钮 */}
      <Button
        variant="ghost"
        size="sm"
        className={cn(
          "h-8",
          "text-xs text-muted-foreground hover:text-foreground",
          "transition-colors"
        )}
        onClick={onRestart}
      >
        <Undo className="h-3 w-3 mr-1" />
        重新开始
      </Button>

      {/* 跳过按钮 */}
      {!disableSkip && (
        <div className="relative group">
          <Button
            variant="ghost"
            size="sm"
            className={cn(
              "h-8",
              "text-xs text-blue-500 hover:text-blue-600",
              "transition-colors"
            )}
            onClick={onSkip}
            disabled={disableSkip}
          >
            {skipInfo.text}
            <ArrowRight className="h-3 w-3 ml-1" />
          </Button>

          {/* 工具提示 */}
          {skipInfo.tooltip && (
            <div className={cn(
              "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2",
              "px-2 py-1 rounded bg-gray-800 text-white text-xs whitespace-nowrap",
              "opacity-0 group-hover:opacity-100 transition-opacity",
              "pointer-events-none"
            )}>
              {skipInfo.tooltip}
              {/* 小三角形 */}
              <div className={cn(
                "absolute -bottom-1 left-1/2 transform -translate-x-1/2",
                "border-4 border-transparent border-t-gray-800"
              )} />
            </div>
          )}
        </div>
      )}

      {/* 在标题关键词步骤且已跳过URL关键词时显示提示 */}
      {currentStep === 'titleKeywords' && disableSkip && (
        <span className="text-xs text-muted-foreground">
          必须设置标题关键词
        </span>
      )}
    </div>
  )
}

export default ActionButtons

================
File: src/components/tag/form/KeywordInput.tsx
================
// src/components/tag/form/KeywordInput.tsx
import React, { useState, useRef, useCallback } from "react"
import { X, Plus } from "lucide-react"
import { Button } from "~/components/ui/button"
import { Input } from "~/components/ui/input"
import { cn } from "~/lib/utils"

interface KeywordInputProps {
  keywords: string[]
  onChange: (keywords: string[]) => void
  onContinue?: () => void  // 添加这个属性
  placeholder?: string
  suggestions?: string[]
  maxKeywords?: number
  disabled?: boolean
  className?: string
}

export const KeywordInput: React.FC<KeywordInputProps> = ({
  keywords,
  onChange,
  onContinue,  // 新增
  placeholder = "输入关键词后按回车添加...",
  suggestions = [],
  maxKeywords = 10,
  disabled = false,
  className
}) => {
  const [inputValue, setInputValue] = useState("")
  const [error, setError] = useState<string>("")
  const inputRef = useRef<HTMLInputElement>(null)

  // 验证关键词
  const validateKeyword = (keyword: string): boolean => {
    if (keyword.length < 2) {
      setError("关键词至少需要2个字符")
      return false
    }
    if (keywords.includes(keyword)) {
      setError("关键词已存在")
      return false
    }
    if (keywords.length >= maxKeywords) {
      setError(`最多只能添加${maxKeywords}个关键词`)
      return false
    }
    return true
  }

  // 添加关键词
  const addKeyword = useCallback((keyword: string) => {
    const trimmedKeyword = keyword.trim()
    if (!trimmedKeyword) return

    // 检查是否已存在（不区分大小写）
    const exists = keywords.some(k => k.toLowerCase() === trimmedKeyword.toLowerCase())
    if (exists) {
      setError("关键词已存在")
      return
    }

    if (validateKeyword(trimmedKeyword)) {
      onChange([...keywords, trimmedKeyword])
      setInputValue("")
      setError("")
    }
  }, [keywords, onChange, maxKeywords])

  // 删除关键词
  const removeKeyword = useCallback((indexToRemove: number) => {
    onChange(keywords.filter((_, index) => index !== indexToRemove))
  }, [keywords, onChange])

  // 处理输入
  const handleInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      if (inputValue) {
        addKeyword(inputValue)
      } else if (keywords.length > 0 && onContinue) {
        // 当输入框为空且已有关键词时，按回车继续
        onContinue()
      }
    } else if (e.key === 'Backspace' && !inputValue && keywords.length > 0) {
      removeKeyword(keywords.length - 1)
    }
    setError("") // 清除错误提示
  }

  return (
    <div className={className}>
      {/* 关键词展示区域 */}
      <div className="flex flex-wrap gap-2 mb-2">
        {keywords.map((keyword, index) => (
          <div
            key={index}
            className={cn(
              "group flex items-center gap-1",
              "px-2 py-1 rounded-md",
              "bg-muted/50 hover:bg-muted/70",
              "border border-border/50",
              "text-sm font-medium",
              "transition-colors duration-200",
              disabled && "opacity-50"
            )}>
            <span>{keyword}</span>
            {!disabled && (
              <Button
                type="button"
                variant="ghost"
                size="icon"
                className={cn(
                  "h-4 w-4 p-0",
                  "opacity-50 hover:opacity-100",
                  "text-muted-foreground hover:text-foreground",
                  "transition-opacity"
                )}
                onClick={() => removeKeyword(index)}>
                <X className="h-3 w-3" />
                <span className="sr-only">删除关键词</span>
              </Button>
            )}
          </div>
        ))}
      </div>

      {/* 输入区域 - 修改这部分 */}
      {!disabled && keywords.length < maxKeywords && (
        <div className="relative flex items-center gap-2">
          <div className="flex-1 relative">
            <Input
              ref={inputRef}
              type="text"
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              onKeyDown={handleInputKeyDown}
              placeholder={placeholder}
              className={cn(
                "pr-12",
                "bg-background",
                "border-muted-foreground/20",
                "h-9",
                error && "border-red-500 focus:border-red-500"
              )}
              disabled={disabled}
            />
            
            {/* 添加关键词按钮 */}
            {inputValue && (
              <Button
                type="button"
                size="icon"
                variant="ghost"
                className={cn(
                  "absolute right-1 top-1",
                  "h-7 w-7",
                  "hover:bg-muted/50"
                )}
                onClick={() => addKeyword(inputValue)}>
                <Plus className="h-4 w-4" />
                <span className="sr-only">添加关键词</span>
              </Button>
            )}
          </div>

          {/* 继续按钮 - 移动到这里 */}
          {keywords.length > 0 && onContinue && (
            <Button
              type="button"
              variant="default"
              size="sm"
              onClick={onContinue}
              className={cn(
                "whitespace-nowrap",
                "bg-primary text-primary-foreground hover:bg-primary/90"
              )}
            >
              下一步
            </Button>
          )}
        </div>
      )}

      {/* 错误提示 */}
      {error && (
        <p className="mt-1 text-xs text-red-500">
          {error}
        </p>
      )}

      {/* 建议区域 */}
      {suggestions.length > 0 && !disabled && (
        <div className="mt-2">
          <p className="text-xs text-muted-foreground mb-1">
            建议的关键词:
          </p>
          <div className="flex flex-wrap gap-2">
            {suggestions.map((suggestion, index) => (
              <Button
                key={index}
                variant="outline"
                size="sm"
                className={cn(
                  "h-7 text-xs",
                  "hover:bg-muted/50"
                )}
                onClick={() => addKeyword(suggestion)}>
                {suggestion}
              </Button>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}

================
File: src/components/tag/form/MessageList.tsx
================
// src/components/tag/form/MessageList.tsx
import React from "react"
import { cn } from "~/lib/utils"

interface Message {
  type: 'assistant' | 'user'
  content: string
  hint?: string
}

interface MessageListProps {
  messages: Message[]
  messagesEndRef: React.RefObject<HTMLDivElement>
}

export const MessageList: React.FC<MessageListProps> = ({
  messages,
  messagesEndRef
}) => {
  return (
    <div className={cn(
      "h-full",
      "overflow-y-auto",
      "p-4 space-y-4",
      "custom-scrollbar"
    )}>
      {messages.map((message, index) => (
        <div
          key={index}
          className={cn(
            "group flex flex-col",
            message.type === 'assistant' ? "items-start" : "items-end"
          )}
        >
          {/* 消息类型标签 */}
          <div className={cn(
            "px-2 py-1 text-xs text-muted-foreground/70",
            message.type === 'assistant' ? "text-left" : "text-right"
          )}>
            {message.type === 'assistant' ? '助手' : '你'}
          </div>
          
          {/* 主要消息内容 */}
          <div className={cn(
            "mt-1 px-4 py-3 rounded-2xl max-w-[85%]",
            "shadow-sm",
            "transition-colors duration-200",
            message.type === 'assistant' 
              ? "bg-muted/50 text-foreground rounded-tl-sm" 
              : "bg-blue-500 text-white rounded-tr-sm",
            "hover:shadow-md"
          )}>
            <div className="whitespace-pre-line text-sm leading-relaxed">
              {message.content}
            </div>

            {/* 提示信息 */}
            {message.hint && (
              <div className={cn(
                "mt-2 pt-2", 
                "border-t border-border/40",
                "text-xs text-muted-foreground/80",
                "whitespace-pre-line leading-relaxed"
              )}>
                {message.hint}
              </div>
            )}
          </div>
        </div>
      ))}
      <div ref={messagesEndRef} className="h-1" />
    </div>
  )
}

================
File: src/components/tag/form/TagForm.tsx
================
// src/components/tag/form/TagForm.tsx
import React from "react"
import { AnimatePresence } from "framer-motion"
import { useTagForm } from "~/hooks/useTagForm"
import { TagFormLayout } from "./TagFormLayout"
import { MessageList } from "./MessageList"
import { ActionButtons } from "./ActionButtons"
import { KeywordInput } from "./KeywordInput"
import { Input } from "~/components/ui/input"
import { TagTemplates } from "./TagTemplates"
import { TagTemplatePreview } from "./TagTemplatePreview"
import { cn } from "~/lib/utils"
import type { Tag } from "~/types/tag"
import { TagIcon } from "lucide-react"

interface TagFormProps {
  onClose: () => void
  onSubmit: (tag: Omit<Tag, "id" | "createdAt" | "updatedAt" | "version">) => Promise<void>
  editingTag?: Tag | null
  isSubmitting?: boolean
}

export const TagForm: React.FC<TagFormProps> = ({
  onClose,
  onSubmit,
  editingTag,
  isSubmitting = false
}) => {
  const {
    currentStep,
    messages,
    formData,
    inputValue,
    hasSkippedUrl,
    selectedTemplate,
    urlSuggestions,
    titleSuggestions,
    messagesEndRef,
    handleSkip,
    handleUserInput,
    handleSubmit,
    handleRestart,
    setInputValue,
    setFormData,
    handleTemplateSelect,
    isUsingTemplate,
  } = useTagForm({ 
    editingTag, 
    onSubmit, 
    onClose 
  })

  const uniqueUrlKeywords = Array.from(new Set(formData.urlKeywords))
  const uniqueTitleKeywords = Array.from(new Set(formData.titleKeywords))


  const renderStepContent = () => {
    switch (currentStep) {
      case 'name':
        return (
          <div className="space-y-3 px-4">
            {/* 名称输入框 - 移除提示文本 */}
            <div>
              <Input
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && inputValue.trim()) {
                    handleUserInput(inputValue)
                  }
                }}
                placeholder="输入标签名称..."
                autoFocus
                className={cn(
                  "bg-background",
                  "!border-border",
                  "hover:border-primary/30",
                  "dark:border-[#2D2F36]",
                  "dark:hover:border-[#2D2F36]",
                  "placeholder:text-muted-foreground/50",
                  "transition-colors duration-200"
                )}
                disabled={isSubmitting}
                maxLength={20}
              />
            </div>
  
            {/* 其他部分保持不变 */}
            {selectedTemplate && (
              <TagTemplatePreview
                template={selectedTemplate}
                className="bg-muted/30 rounded-md p-2"
              />
            )}
  
            <div className="space-y-1.5">
              <p className="text-xs font-medium text-muted-foreground">推荐的标签模板:</p>
              <TagTemplates 
                onSelect={handleTemplateSelect}
                className="gap-1.5"
              />
            </div>
          </div>
        )

      case 'urlKeywords':
        return (
          <div className="p-4 space-y-2">
            <KeywordInput
              keywords={formData.urlKeywords}
              onChange={(keywords) => setFormData(prev => ({
                ...prev,
                urlKeywords: keywords
              }))}
              onContinue={() => handleUserInput(formData.urlKeywords.join(', '))}
              placeholder="输入网址关键词..."
              suggestions={urlSuggestions}
              maxKeywords={10}
              disabled={isSubmitting}
              className={cn(
                "w-full",
                "bg-background",
                "border-border",
                "hover:border-primary/30",
                "dark:border-[#2D2F36]",
                "dark:hover:border-[#2D2F36]",
                "placeholder:text-muted-foreground/50",
                "transition-colors duration-200"
              )}
            />
          </div>
        )

      case 'titleKeywords':
        return (
          <div className="p-4 space-y-2">
            <KeywordInput
              keywords={formData.titleKeywords}
              onChange={(keywords) => setFormData(prev => ({
                ...prev,
                titleKeywords: keywords
              }))}
              onContinue={() => handleUserInput(formData.titleKeywords.join(', '))}
              placeholder="输入标题关键词..."
              suggestions={titleSuggestions}
              maxKeywords={hasSkippedUrl ? 5 : 10}
              disabled={isSubmitting}
              className={cn(
                "w-full",
                "bg-background",
                "border-border",
                "hover:border-primary/30",
                "dark:border-[#2D2F36]",
                "dark:hover:border-[#2D2F36]",
                "placeholder:text-muted-foreground/50",
                "transition-colors duration-200"
              )}
            />
          </div>
        )

        case 'confirm':
          if (!isUsingTemplate) return null
          
          return (
            <div className="p-4">
              <div className={cn(
                "p-4 rounded-lg",
                "bg-muted/30",
                "border border-border/40",
                "space-y-3"
              )}>
                <div className="flex items-center gap-2 pb-2 border-b border-border/40">
                  <TagIcon className="h-4 w-4 text-blue-500" />
                  <h3 className="font-medium text-blue-500">标签信息确认</h3>
                </div>
                
                <div className="space-y-2 text-sm">
                  <div className="flex items-start gap-2">
                    <span className="text-muted-foreground min-w-20">标签名称:</span>
                    <span className="font-medium">{formData.name}</span>
                  </div>
                  
                  <div className="flex items-start gap-2">
                    <span className="text-muted-foreground min-w-20">URL关键词:</span>
                    <span className="font-medium">
                      {uniqueUrlKeywords.length > 0 
                        ? uniqueUrlKeywords.join(", ")
                        : "未设置"}
                    </span>
                  </div>
                  
                  <div className="flex items-start gap-2">
                    <span className="text-muted-foreground min-w-20">标题关键词:</span>
                    <span className="font-medium">
                      {uniqueTitleKeywords.length > 0
                        ? uniqueTitleKeywords.join(", ")
                        : "未设置"}
                    </span>
                  </div>
                </div>
        
                {/* 添加提示信息 */}
                <div className="mt-3 pt-3 border-t border-border/40 text-xs text-muted-foreground">
                  请确认以上信息是否正确。如需修改,请点击"重新开始"。
                </div>
              </div>
            </div>
          )

      default:
        return null
    }
  }

  return (
    <AnimatePresence>
      <TagFormLayout
        title={editingTag ? '编辑标签' : '创建标签自动分类规则'}
        onClose={onClose}
      >
        {/* 修改这里的布局结构 */}
        <div className="flex flex-col h-[calc(100vh-8rem)] tag-form-content no-default-border"> {/* 确保整体容器有固定高度 */}
          {/* 消息列表区域 - 添加滚动 */}
          <div className="flex-1 min-h-0 tag-form-content no-default-border"> {/* min-h-0 是关键，让 flex-1 正常工作 */}
            <MessageList 
              messages={messages}
              messagesEndRef={messagesEndRef}
            />
          </div>
  
          {/* 表单操作区域 - 固定在底部 */}
          <div className="flex-shrink-0 border-t bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
            <ActionButtons
              currentStep={currentStep}
              isSubmitting={isSubmitting}
              onSkip={handleSkip}
              onConfirm={handleSubmit}
              onCancel={onClose}
              onRestart={handleRestart}
              disableSkip={currentStep === 'titleKeywords' && hasSkippedUrl}
              isUsingTemplate={isUsingTemplate}
            />
            
            {/* 步骤内容 */}
            {renderStepContent()}
          </div>
        </div>
      </TagFormLayout>
    </AnimatePresence>
  )
}

export default TagForm

================
File: src/components/tag/form/InputArea.tsx
================
import React from "react"
import type { MutableRefObject, Dispatch, SetStateAction } from "react"
import { Input } from "~/components/ui/input"
import { Button } from "~/components/ui/button"
import { Loader2, SendHorizontal } from "lucide-react"
import { cn } from "~/lib/utils"

interface InputAreaProps {
  inputValue: string
  inputRef: MutableRefObject<HTMLInputElement>
  currentStep: 'name' | 'urlKeywords' | 'titleKeywords' | 'confirm'
  isSubmitting: boolean
  onChange: Dispatch<SetStateAction<string>>
  onSubmit: () => void
  placeholder?: string
  disabled: boolean
}

export const InputArea: React.FC<InputAreaProps> = ({
  inputValue,
  inputRef,
  currentStep,
  isSubmitting,
  onChange,
  onSubmit,
  placeholder,
  disabled
}) => {
  const getPlaceholder = () => {
    switch (currentStep) {
      case 'name':
        return "请输入标签名称..."
      case 'confirm':
        return "请使用上方按钮确认或取消"
    }
  }

  return (
    <div className="px-4 py-3">
      <div className="relative flex-1">
        <Input
          ref={inputRef}
          value={inputValue}
          onChange={(e) => onChange(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === 'Enter' && !e.shiftKey && inputValue.trim()) {
              e.preventDefault()
              onSubmit()
            }
          }}
          placeholder={getPlaceholder()}
          disabled={currentStep === 'confirm' || isSubmitting}
          className={cn(
            "pr-12",
            "bg-background",
            "border-muted-foreground/20",
            "focus:border-muted-foreground/30",
            "placeholder:text-muted-foreground/50",
            "transition-colors duration-200"
          )}
        />
        <Button
          size="icon"
          className={cn(
            "absolute right-1 top-1 h-7 w-7",
            "bg-transparent hover:bg-muted/50",
            !inputValue.trim() && "opacity-50 cursor-not-allowed",
            "transition-all duration-200"
          )}
          onClick={() => inputValue.trim() && onSubmit()}
          disabled={!inputValue.trim() || isSubmitting || currentStep === 'confirm'}
        >
          {isSubmitting ? (
            <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
          ) : (
            <SendHorizontal className="h-4 w-4 text-muted-foreground" />
          )}
        </Button>
      </div>
    </div>
  )
}

================
File: src/components/tag/form/TagFormLayout.tsx
================
import React from "react"
import { motion } from "framer-motion"
import { X } from "lucide-react"
import { Button } from "~/components/ui/button"

interface TagFormLayoutProps {
  children: React.ReactNode
  title: string
  onClose: () => void
}

export const TagFormLayout: React.FC<TagFormLayoutProps> = ({
  children,
  title,
  onClose
}) => {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      transition={{ duration: 0.2 }}
      className="fixed inset-0 bg-background/80 backdrop-blur-sm z-50"
    >
      <motion.div
        initial={{ scale: 0.95, opacity: 0, y: 20 }}
        animate={{ scale: 1, opacity: 1, y: 0 }}
        exit={{ scale: 0.95, opacity: 0, y: 20 }}
        transition={{
          duration: 0.2,
          ease: [0.4, 0, 0.2, 1]
        }}
        className="fixed inset-0 bg-background overflow-hidden"
      >
        {/* 修改这里的布局结构 */}
        <div className="flex flex-col h-full">
          {/* 头部 */}
          <div className="flex items-center justify-between px-4 py-2 border-b flex-shrink-0">
            <h3 className="text-base font-medium">{title}</h3>
            <Button 
              variant="ghost" 
              size="icon"
              className="h-8 w-8 hover:bg-muted/50" 
              onClick={onClose}
            >
              <X className="h-4 w-4" />
              <span className="sr-only">关闭</span>
            </Button>
          </div>

          {/* 内容区域 */}
          <div className="flex-1 overflow-hidden">
            {children}
          </div>
        </div>
      </motion.div>
    </motion.div>
  )
}

================
File: src/hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "~/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: src/hooks/useTagForm.ts
================
// src/hooks/useTagForm.ts
import { useState, useRef, useEffect, useCallback } from "react"
import { tagStorage } from "~/services/storage"
import type { Tag, TagTemplate } from "~/types/tag"

type Step = 'name' | 'urlKeywords' | 'titleKeywords' | 'confirm'

interface Message {
  type: 'assistant' | 'user'
  content: string
  hint?: string // 添加提示信息字段
}


interface FormData {
  name: string;
  urlKeywords: string[];
  titleKeywords: string[];
}

interface UseTagFormProps {
  editingTag?: Tag | null;
  onSubmit: (tag: Omit<Tag, "id" | "createdAt" | "updatedAt" | "version">) => Promise<void>;
  onClose: () => void;
}

// src/hooks/useTagForm.ts
export const useTagForm = ({ editingTag, onSubmit, onClose }: UseTagFormProps) => {
  // 状态定义
  const [currentStep, setCurrentStep] = useState<Step>('name')
  const [messages, setMessages] = useState<Message[]>([{
    type: 'assistant',
    content: '让我帮你创建一个新的标签。你可以直接输入标签名称,或者从下方选择一个推荐的模板。',
    hint: '💡 小提示: 标签名称建议在20个字符以内,便于别和管理。'
  }])
  const [formData, setFormData] = useState<FormData>({
    name: editingTag?.name || '',
    urlKeywords: editingTag?.conditions?.urlKeywords || [],
    titleKeywords: editingTag?.conditions?.titleKeywords || []
  })
  const [inputValue, setInputValue] = useState('')
  const [hasSkippedUrl, setHasSkippedUrl] = useState(false)
  const [selectedTemplate, setSelectedTemplate] = useState<TagTemplate | null>(null)
  const [urlSuggestions, setUrlSuggestions] = useState<string[]>([])
  const [titleSuggestions, setTitleSuggestions] = useState<string[]>([])
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [isUsingTemplate, setIsUsingTemplate] = useState(false)

  const messagesEndRef = useRef<HTMLDivElement>(null)

  // 生成摘要信息
  const generateSummary = (data: FormData): string => {
    let summary = `📌 标签名称: ${data.name}\n`
    
    if (data.urlKeywords.length === 0 && data.titleKeywords.length === 0) {
      summary += `⚠️ 警告：必须设置至少一种关键词！\n\n`
    }
    
    if (data.urlKeywords.length > 0) {
      summary += `🔗 URL关键词: ${data.urlKeywords.join(', ')}\n`
    } else {
      summary += `🔗 URL关键词: 未设置\n`
    }
    
    if (data.titleKeywords.length > 0) {
      summary += `📝 标题关键词: ${data.titleKeywords.join(', ')}\n`
    } else {
      summary += `📝 标题关键词: 未设置\n`
    }
    
    return summary
  }

  // 添加一个生成预览文本的辅助函数
  const generatePreviewText = (data: FormData) => {
    const parts = [
      `名称: ${data.name}`,
      `URL关键词: ${data.urlKeywords.length > 0 ? data.urlKeywords.join(", ") : "未设置"}`,
      `标题关键词: ${data.titleKeywords.length > 0 ? data.titleKeywords.join(", ") : "未设置"}`
    ]
    return parts.join("\n")
  }

  // 处理提交 - 将handleSubmit移到前面
  const handleSubmit = useCallback(async () => {
    try {
      if (formData.urlKeywords.length === 0 && formData.titleKeywords.length === 0) {
        setMessages(prev => [...prev, {
          type: 'assistant',
          content: '❌ 错误：必须至少设置一种类型的关键词。'
        }])
        return
      }

      setIsSubmitting(true)
      await onSubmit({
        name: formData.name,
        conditions: {
          urlKeywords: formData.urlKeywords,
          titleKeywords: formData.titleKeywords
        }
      })

      setMessages(prev => [...prev, {
        type: 'assistant',
        content: '✨ 标签创建成功！'
      }])
      
      setTimeout(onClose, 1500)
    } catch (error) {
      console.error('Failed to save tag:', error)
      setMessages(prev => [...prev, {
        type: 'assistant',
        content: '❌ 创建失败，请重试。'
      }])
    } finally {
      setIsSubmitting(false)
    }
  }, [formData, onSubmit, onClose])

  // 处理跳过操作
  const handleSkip = useCallback(() => {
    switch (currentStep) {
      case 'urlKeywords':
        setHasSkippedUrl(true)
        setMessages(prev => [...prev, {
          type: 'assistant',
          content: '已跳过网址关键词设置,请输入需要匹配的标题关键词。',
          hint: '💡 小提示: 由于已跳过网址关键词，必须设置标题关键词。'
        }])
        setCurrentStep('titleKeywords')
        break
      case 'titleKeywords':
        if (hasSkippedUrl) {
          setMessages(prev => [...prev, {
            type: 'assistant',
            content: '⚠️ 由于已跳过网址关键词，必须设置标题关键词。请输入至少一个关键词。'
          }])
          return
        }
        setMessages(prev => [...prev, {
          type: 'assistant',
          content: '已跳过标题关键词设置。\n\n让我们确认标签信息：\n\n' + generateSummary(formData)
        }])
        setCurrentStep('confirm')
        break
    }
    setInputValue('')
  }, [currentStep, hasSkippedUrl, formData])

  // 添加检查标签名称是否存在的函数
  const checkTagNameExists = async (name: string): Promise<Tag | null> => {
    try {
      const existingTags = await tagStorage.getAllTags()
      return existingTags.find(tag => 
        tag.name.toLowerCase() === name.toLowerCase() &&
        // 如果是编辑模式，排除当前编辑的标签
        (!editingTag || tag.id !== editingTag.id)
      ) || null
    } catch (error) {
      console.error('Failed to check tag name:', error)
      return null
    }
  }

  // 修改处理用户输入的函数
  const handleUserInput = async (input: string) => {
    if (!input.trim()) return

    setMessages(prev => [...prev, {
      type: 'user',
      content: input
    }])

    switch (currentStep) {
      case 'name':
        // 名称验证逻辑保持不变
        const existingTag = await checkTagNameExists(input)
        
        if (existingTag) {
          setMessages(prev => [...prev, {
            type: 'assistant',
            content: `注意：已存在名为"${input}"的标签，继续操作将会覆盖原有标签的设置。`,
            hint: '你可以继续操作，原有标签的设置将被覆盖。'
          }])
        }

        setFormData(prev => ({
          ...prev,
          name: input
        }))
        setCurrentStep('urlKeywords')
        break

      case 'urlKeywords':
        const urlKeywords = input.split(',')
          .map(k => k.trim())
          .filter(Boolean)
        setFormData(prev => ({
          ...prev,
          urlKeywords: urlKeywords  // 直接设置,不合并
        }))
        setCurrentStep('titleKeywords')
        setMessages(prev => [...prev, {
          type: 'assistant',
          content: `已设置URL关键词[${urlKeywords.join(', ')}],接下来请输入"标题关键词"。`,
          hint: '💡 标题关键词将用于匹配书签的标题内容。'
        }])
        break

        case 'titleKeywords':
          const titleKeywords = input.split(',')
            .map(k => k.trim())
            .filter(Boolean)
          setFormData(prev => ({
            ...prev,
            titleKeywords: titleKeywords
          }))
          
          setCurrentStep('confirm')
          setMessages(prev => [...prev, {
            type: 'assistant',
            content: '已添加标题关键词。请确认是否创建标签：\n\n' + generatePreviewText(formData)
          }])
          break

      case 'confirm':
        handleSubmit()
        break
    }
    
    setInputValue('')
  }

  // 处理重新开始
  const handleRestart = useCallback(() => {
    setCurrentStep('name')
    setFormData({
      name: '',
      urlKeywords: [],
      titleKeywords: []
    })
    setHasSkippedUrl(false)
    setInputValue('')
    setSelectedTemplate(null)
    setMessages([{
      type: 'assistant',
      content: '让我帮你创建一个新的标签。首先，这个标签叫什么名字？'
    }])
  }, [])

  // 处理模板选择
  const handleTemplateSelect = useCallback((template: TagTemplate) => {
    setSelectedTemplate(template)
    setIsUsingTemplate(true)
    setFormData({
      name: template.name,
      urlKeywords: template.conditions.urlKeywords,
      titleKeywords: template.conditions.titleKeywords
    })

    setMessages(prev => [...prev, {
      type: 'assistant',
      content: `已选择 "${template.name}" 模板${template.description ? `\n${template.description}` : ''}。`
    }])

    setCurrentStep('confirm')
  }, [])

  // 处理消息滚动
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  return {
    currentStep,
    messages,
    formData,
    inputValue,
    hasSkippedUrl,
    selectedTemplate,
    urlSuggestions,
    titleSuggestions,
    messagesEndRef,
    isSubmitting,
    handleSkip,
    handleUserInput,
    handleSubmit,
    handleRestart,
    handleTemplateSelect,
    setInputValue,
    setFormData,
    isUsingTemplate,
  }
}

================
File: src/hooks/useDebounce.ts
================
// src/hooks/useDebounce.ts
import { useState, useEffect } from 'react'

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => {
      clearTimeout(timer)
    }
  }, [value, delay])

  return debouncedValue
}

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function isToday(timestamp: number): boolean {
  const date = new Date(timestamp);
  const today = new Date();
  return date.getDate() === today.getDate() &&
    date.getMonth() === today.getMonth() &&
    date.getFullYear() === today.getFullYear();
}

================
File: src/lib/events.ts
================
// src/lib/events.ts
type EventType = 'REFRESH_RECENT'

const eventBus = {
  listeners: new Map<EventType, Set<() => void>>(),

  on(event: EventType, callback: () => void) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set())
    }
    this.listeners.get(event)!.add(callback)
  },

  off(event: EventType, callback: () => void) {
    this.listeners.get(event)?.delete(callback)
  },

  emit(event: EventType) {
    this.listeners.get(event)?.forEach(callback => callback())
  }
}

export default eventBus

================
File: src/services/icons.ts
================
// src/services/icons.ts
import { 
  Folder, Code2, DollarSign, School, 
  FileCode2, type LucideIcon 
} from "lucide-react"

// 图标服务接口
export interface IconService {
  getFolderIcon(title: string): LucideIcon
  getFaviconUrl(url: string): string
  getDefaultIcon(title: string): string
}

class ChromeIconService implements IconService {
  private static FOLDER_ICON_MAPPING: Record<string, LucideIcon> = {
    money: DollarSign,
    finance: DollarSign,
    code: Code2,
    php: Code2,
    python: Code2,
    learn: School,
    course: School,
    tutorial: School
  }

  // 获取文件夹图标
  getFolderIcon(title: string): LucideIcon {
    const lowerTitle = title.toLowerCase()
    for (const [key, icon] of Object.entries(ChromeIconService.FOLDER_ICON_MAPPING)) {
      if (lowerTitle.includes(key)) {
        return icon
      }
    }
    return Folder
  }

  // 获取网站图标 URL
  getFaviconUrl(url: string): string {
    try {
      const urlObject = new URL(url)
      // 使用更大尺寸的图标
      return `https://www.google.com/s2/favicons?domain=${urlObject.hostname}&sz=64` // 从 32 改为 64
    } catch (e) {
      console.error('Invalid URL:', url, e)
      return ''
    }
  }

  // 获取默认图标（当 favicon 加载失败时使用）
  getDefaultIcon(title: string): string {
    return title?.[0]?.toUpperCase() || '?'
  }

  // 异步检查图标 URL 是否可用
  async checkIconAvailability(url: string): Promise<boolean> {
    if (!url) return false
    
    try {
      const response = await fetch(url, { method: 'HEAD' })
      return response.ok
    } catch (e) {
      console.error('Error checking icon availability:', e)
      return false
    }
  }
}

// 导出单例实例
export const iconService = new ChromeIconService()

================
File: src/services/storage/tag.ts
================
// src/services/storage/tag.ts
import { BaseStorageService, ChromeStorageAdapter } from "./base"
import type { Tag, TagStorage } from "~/types/tag"

const TAG_STORAGE_KEY = "Linkit_tags"
const TAG_STORAGE_VERSION = 1

export class TagStorageService extends BaseStorageService<TagStorage> {
  private cache: Map<string, Tag> = new Map()

  constructor() {
    super(new ChromeStorageAdapter(), TAG_STORAGE_KEY, TAG_STORAGE_VERSION)
  }

  async initialize(): Promise<void> {
    try {
      const storage = await this.getData()
      if (!storage) {
        await this.setData({
          version: this.version,
          tags: []
        })
      } else if (storage.version < this.version) {
        await this.migrateData(storage)
      }
      await this.loadToCache()
    } catch (error) {
      console.error("Failed to initialize tag storage:", error)
      throw new Error("Tag storage initialization failed")
    }
  }

  async getAllTags(): Promise<Tag[]> {
    const storage = await this.getData()
    return storage?.tags || []
  }

  async getTag(id: string): Promise<Tag | null> {
    const cached = this.cache.get(id)
    if (cached) return cached

    const storage = await this.getData()
    const tag = storage?.tags?.find(t => t.id === id) || null
    if (tag) {
      this.cache.set(id, tag)
    }
    return tag
  }

  async isTagNameExists(name: string, excludeId?: string): Promise<boolean> {
    const tags = await this.getAllTags()
    return tags.some(tag => 
      tag.name.toLowerCase() === name.toLowerCase() && 
      (!excludeId || tag.id !== excludeId)
    )
  }

  async createTag(tagData: Omit<Tag, "id" | "createdAt" | "updatedAt" | "version">): Promise<Tag> {
    const isExists = await this.isTagNameExists(tagData.name)
    if (isExists) {
      throw new Error(`Tag name "${tagData.name}" already exists`)
    }

    const storage = await this.getData()
    const newTag: Tag = {
      ...tagData,
      id: crypto.randomUUID(),
      createdAt: Date.now(),
      updatedAt: Date.now(),
      version: this.version
    }

    const updatedTags = [...(storage?.tags || []), newTag]
    await this.setData({
      version: this.version,
      tags: updatedTags
    })

    this.cache.set(newTag.id, newTag)
    return newTag
  }

  async updateTag(id: string, updates: Partial<Omit<Tag, "id" | "createdAt" | "version">>): Promise<Tag> {
    const storage = await this.getData()
    const tagIndex = storage?.tags?.findIndex(t => t.id === id)
    
    if (tagIndex === -1) {
      throw new Error("Tag not found")
    }

    const updatedTag = {
      ...storage.tags[tagIndex],
      ...updates,
      updatedAt: Date.now()
    }

    const updatedTags = [...storage.tags]
    updatedTags[tagIndex] = updatedTag

    await this.setData({
      version: this.version,
      tags: updatedTags
    })

    this.cache.set(id, updatedTag)
    return updatedTag
  }

  async deleteTag(id: string): Promise<void> {
    const storage = await this.getData()
    const updatedTags = storage?.tags?.filter(t => t.id !== id) || []

    await this.setData({
      version: this.version,
      tags: updatedTags
    })

    this.cache.delete(id)
  }

  clearCache(): void {
    this.cache.clear()
  }

  private async migrateData(oldStorage: any): Promise<void> {
    const migratedTags = oldStorage.tags.map(tag => ({
      ...tag,
      version: this.version,
      createdAt: tag.createdAt || Date.now(),
      updatedAt: Date.now()
    }))

    await this.setData({
      version: this.version,
      tags: migratedTags
    })
  }

  private async loadToCache(): Promise<void> {
    const storage = await this.getData()
    this.cache.clear()
    storage?.tags?.forEach(tag => {
      this.cache.set(tag.id, tag)
    })
  }
}

// 导出单例实例
export const tagStorage = new TagStorageService()

================
File: src/services/storage/base.ts
================
// src/services/storage/base.ts
export interface StorageAdapter {
  get(key: string): Promise<any>
  set(key: string, value: any): Promise<void>
  remove(key: string): Promise<void>
}

// Chrome Storage 适配器
export class ChromeStorageAdapter implements StorageAdapter {
  async get(key: string): Promise<any> {
    const result = await chrome.storage.local.get(key)
    return result[key]
  }

  async set(key: string, value: any): Promise<void> {
    await chrome.storage.local.set({ [key]: value })
  }

  async remove(key: string): Promise<void> {
    await chrome.storage.local.remove(key)
  }
}

// 基础存储服务
export abstract class BaseStorageService<T> {
  protected constructor(
    protected readonly adapter: StorageAdapter,
    protected readonly storageKey: string,
    protected readonly version: number,
  ) {}

  protected async getData(): Promise<T | null> {
    try {
      return await this.adapter.get(this.storageKey)
    } catch (error) {
      console.error(`Failed to get data from ${this.storageKey}:`, error)
      return null
    }
  }

  protected async setData(data: T): Promise<void> {
    try {
      await this.adapter.set(this.storageKey, data)
    } catch (error) {
      console.error(`Failed to set data for ${this.storageKey}:`, error)
      throw error
    }
  }

  protected async removeData(): Promise<void> {
    try {
      await this.adapter.remove(this.storageKey)
    } catch (error) {
      console.error(`Failed to remove data for ${this.storageKey}:`, error)
      throw error
    }
  }
}

================
File: src/services/storage/hint.ts
================
// src/services/storage/hint.ts
import { BaseStorageService, ChromeStorageAdapter } from "./base"

interface HintStorage {
  hasShownSidePanelHint: boolean
}

const HINT_STORAGE_KEY = "Linkit_hints"
const HINT_STORAGE_VERSION = 1

class HintStorageService extends BaseStorageService<HintStorage> {
  constructor() {
    super(new ChromeStorageAdapter(), HINT_STORAGE_KEY, HINT_STORAGE_VERSION)
  }

  async hasSidePanelHintShown(): Promise<boolean> {
    const storage = await this.getData()
    return storage?.hasShownSidePanelHint || false
  }

  async markSidePanelHintShown(): Promise<void> {
    await this.setData({
      hasShownSidePanelHint: true
    })
  }
}

export const hintStorage = new HintStorageService()

================
File: src/services/storage/settings.ts
================
// src/services/storage/settings.ts
import { BaseStorageService, ChromeStorageAdapter } from "./base"
import type { Settings } from "~/types/settings"
import { DEFAULT_SETTINGS } from "~/types/settings"

const SETTINGS_STORAGE_KEY = "Linkit_settings"
const SETTINGS_STORAGE_VERSION = 1

export class SettingsStorageService extends BaseStorageService<Settings> {
  constructor() {
    super(new ChromeStorageAdapter(), SETTINGS_STORAGE_KEY, SETTINGS_STORAGE_VERSION)
  }

  async getSettings(): Promise<Settings> {
    const settings = await this.getData()
    return { ...DEFAULT_SETTINGS, ...settings }
  }

  async updateSettings(updates: Partial<Settings>): Promise<Settings> {
    const currentSettings = await this.getSettings()
    const newSettings = {
      ...currentSettings,
      ...updates
    }
    await this.setData(newSettings)
    return newSettings
  }
}

// 导出单例实例
export const settingsStorage = new SettingsStorageService()

================
File: src/services/storage/visit.ts
================
import { BaseStorageService, ChromeStorageAdapter } from "./base"

interface BookmarkVisit {
  id: string
  count: number
  lastVisited: number
}

interface VisitStorage {
  version: number
  visits: BookmarkVisit[]
}

const VISIT_STORAGE_KEY = "Linkit_visits"
const VISIT_STORAGE_VERSION = 1

export class VisitStorageService extends BaseStorageService<VisitStorage> {
  constructor() {
    super(new ChromeStorageAdapter(), VISIT_STORAGE_KEY, VISIT_STORAGE_VERSION)
  }

  async initialize(): Promise<void> {
    const storage = await this.getData()
    if (!storage) {
      await this.setData({
        version: this.version,
        visits: []
      })
    }
  }

  async recordVisit(id: string): Promise<void> {
    const storage = await this.getData() || {
      version: this.version,
      visits: []
    }

    const existingVisit = storage.visits.find(v => v.id === id)
    const now = Date.now()

    if (existingVisit) {
      existingVisit.count++
      existingVisit.lastVisited = now
    } else {
      storage.visits.push({
        id,
        count: 1,
        lastVisited: now
      })
    }

    await this.setData(storage)
  }

  async getHotBookmarks(limit: number = 20): Promise<BookmarkVisit[]> {
    const storage = await this.getData()
    if (!storage) return []

    return storage.visits
      .sort((a, b) => b.count - a.count)
      .slice(0, limit)
  }

  async clearVisits(): Promise<void> {
    await this.setData({
      version: VISIT_STORAGE_VERSION,
      visits: []
    })
  }
}

export const visitStorage = new VisitStorageService()

================
File: src/services/storage/index.ts
================
// src/services/storage/index.ts
export * from './base'
export * from './tag'
export * from './settings'
export * from './description'
export * from './pin'
export * from './hint'

================
File: src/services/storage/theme.ts
================
import { BaseStorageService, ChromeStorageAdapter } from "./base"

type Theme = 'light' | 'dark'

const THEME_STORAGE_KEY = "Linkit_theme"
const THEME_STORAGE_VERSION = 1

class ThemeStorageService extends BaseStorageService<Theme> {
  constructor() {
    super(new ChromeStorageAdapter(), THEME_STORAGE_KEY, THEME_STORAGE_VERSION)
  }

  async getTheme(): Promise<Theme | null> {
    return this.getData()
  }

  async setTheme(theme: Theme): Promise<void> {
    await this.setData(theme)
  }
}

export const themeStorage = new ThemeStorageService()

================
File: src/services/storage/description.ts
================
// src/services/storage/description.ts
import { BaseStorageService, ChromeStorageAdapter } from "./base"

// 描述数据类型定义
export interface BookmarkDescription {
  id: string
  description: string
  updatedAt: number
}

// 存储结构定义
interface DescriptionStorage {
  version: number
  descriptions: BookmarkDescription[]
}

const DESCRIPTION_STORAGE_KEY = "Linkit_descriptions"
const DESCRIPTION_STORAGE_VERSION = 1

export class DescriptionStorageService extends BaseStorageService<DescriptionStorage> {
  constructor() {
    super(
      new ChromeStorageAdapter(),
      DESCRIPTION_STORAGE_KEY,
      DESCRIPTION_STORAGE_VERSION
    )
  }

  // 初始化
  async initialize(): Promise<void> {
    const storage = await this.getData()
    if (!storage) {
      await this.setData({
        version: this.version,
        descriptions: []
      })
    }
  }

  // 获取描述
  async getDescription(id: string): Promise<string> {
    try {
      const storage = await this.getData()
      if (!storage) return ""
      
      const description = storage.descriptions.find(d => d.id === id)
      return description?.description || ""
    } catch (error) {
      console.error("Failed to get description:", error)
      return ""
    }
  }

  // 获取所有描述
  async getAllDescriptions(): Promise<BookmarkDescription[]> {
    const storage = await this.getData()
    return storage?.descriptions || []
  }

  // 设置描述
  async setDescription(id: string, description: string): Promise<void> {
    try {
      const storage = await this.getData() || {
        version: this.version,
        descriptions: []
      }

      const existingIndex = storage.descriptions.findIndex(d => d.id === id)
      const newDescription: BookmarkDescription = {
        id,
        description: description.trim(),
        updatedAt: Date.now()
      }

      let updatedDescriptions = [...storage.descriptions]
      if (existingIndex >= 0) {
        updatedDescriptions[existingIndex] = newDescription
      } else {
        updatedDescriptions.push(newDescription)
      }

      await this.setData({
        version: this.version,
        descriptions: updatedDescriptions
      })
    } catch (error) {
      console.error("Failed to set description:", error)
      throw error
    }
  }

  // 删除描述
  async removeDescription(id: string): Promise<void> {
    try {
      const storage = await this.getData()
      if (!storage) return

      const updatedDescriptions = storage.descriptions.filter(d => d.id !== id)
      
      await this.setData({
        version: this.version,
        descriptions: updatedDescriptions
      })
    } catch (error) {
      console.error("Failed to remove description:", error)
      throw error
    }
  }

  // 批量搜索描述
  async searchDescriptions(query: string): Promise<BookmarkDescription[]> {
    try {
      const storage = await this.getData()
      if (!storage) return []

      return storage.descriptions.filter(d => 
        d.description.toLowerCase().includes(query.toLowerCase())
      )
    } catch (error) {
      console.error("Failed to search descriptions:", error)
      return []
    }
  }

  // 清理无效的描述（对应的书签已被删除）
  async cleanupOrphanedDescriptions(validBookmarkIds: string[]): Promise<void> {
    try {
      const storage = await this.getData()
      if (!storage) return

      const validDescriptions = storage.descriptions.filter(d => 
        validBookmarkIds.includes(d.id)
      )

      if (validDescriptions.length !== storage.descriptions.length) {
        await this.setData({
          version: this.version,
          descriptions: validDescriptions
        })
      }
    } catch (error) {
      console.error("Failed to cleanup descriptions:", error)
    }
  }
}

// 导出单例实例
export const descriptionStorage = new DescriptionStorageService()

================
File: src/services/storage/pin.ts
================
// src/services/storage/pin.ts
import { BaseStorageService, ChromeStorageAdapter } from "./base"

interface PinStorage {
  version: number
  pinnedBookmarks: string[]
  pinnedFolders: string[]
}

const PIN_STORAGE_KEY = "Linkit_pins"
const PIN_STORAGE_VERSION = 1

export class PinStorageService extends BaseStorageService<PinStorage> {
  constructor() {
    super(new ChromeStorageAdapter(), PIN_STORAGE_KEY, PIN_STORAGE_VERSION)
  }

  async initialize(): Promise<void> {
    const storage = await this.getData()
    if (!storage) {
      await this.setData({
        version: this.version,
        pinnedBookmarks: [],
        pinnedFolders: []
      })
    }
  }

  // 书签相关方法
  async getPinnedBookmarkIds(): Promise<string[]> {
    const storage = await this.getData()
    return storage?.pinnedBookmarks || []
  }

  async addPinnedBookmark(id: string): Promise<void> {
    const storage = await this.getData() || {
      version: this.version,
      pinnedBookmarks: [],
      pinnedFolders: []
    }
    
    if (!storage.pinnedBookmarks.includes(id)) {
      await this.setData({
        ...storage,
        pinnedBookmarks: [...storage.pinnedBookmarks, id]
      })
    }
  }

  async removePinnedBookmark(id: string): Promise<void> {
    const storage = await this.getData()
    if (!storage) return

    await this.setData({
      ...storage,
      pinnedBookmarks: storage.pinnedBookmarks.filter(pinnedId => pinnedId !== id)
    })
  }

  // 文件夹相关方法
  async getPinnedFolderIds(): Promise<string[]> {
    const storage = await this.getData()
    return storage?.pinnedFolders || []
  }

  async addPinnedFolder(id: string): Promise<void> {
    const storage = await this.getData() || {
      version: this.version,
      pinnedBookmarks: [],
      pinnedFolders: []
    }
    
    if (!storage.pinnedFolders.includes(id)) {
      await this.setData({
        ...storage,
        pinnedFolders: [...storage.pinnedFolders, id]
      })
    }
  }

  async removePinnedFolder(id: string): Promise<void> {
    const storage = await this.getData()
    if (!storage) return

    await this.setData({
      ...storage,
      pinnedFolders: storage.pinnedFolders.filter(folderId => folderId !== id)
    })
  }
}

export const pinStorage = new PinStorageService()

================
File: src/services/bookmarks/tag.ts
================
// src/services/bookmarks/tag.ts
import { ChromeBookmarkBaseService } from "./base"
import type { BookmarkTreeNode } from "~/types/bookmark"

interface MatchConditions {
  urlKeywords?: string[]
  titleKeywords?: string[]
  dateRange?: {
    start?: Date
    end?: Date
  }
}

export class BookmarkTagService {
  private bookmarkService: ChromeBookmarkBaseService

  constructor() {
    this.bookmarkService = new ChromeBookmarkBaseService()
  }

  async searchByTag(conditions: MatchConditions): Promise<BookmarkTreeNode[]> {
    console.log('Searching bookmarks by tag with conditions:', conditions)
    try {
      const tree = await this.bookmarkService.getTree()
      const matches: BookmarkTreeNode[] = []

      // 递归搜索函数
      const searchInNode = (node: BookmarkTreeNode) => {
        // 如果是书签(有URL)
        if (node.url) {
          let shouldAdd = false

          // URL关键词匹配检查
          if (conditions.urlKeywords?.length > 0) {
            const urlLower = node.url.toLowerCase()
            const urlMatch = conditions.urlKeywords.some(keyword => 
              urlLower.includes(keyword.toLowerCase())
            )
            shouldAdd = urlMatch
          }

          // 标题关键词匹配检查
          if (conditions.titleKeywords?.length > 0) {
            const titleLower = node.title.toLowerCase()
            const titleMatch = conditions.titleKeywords.some(keyword =>
              titleLower.includes(keyword.toLowerCase())
            )
            
            // 如果有 URL 关键词，就需要两个条件都匹配
            // 如果只有标题关键词，那么只需要标题匹配
            if (conditions.urlKeywords?.length > 0) {
              shouldAdd = shouldAdd && titleMatch
            } else {
              shouldAdd = titleMatch
            }
          }

          // 如果满足匹配条件，检查日期范围
          if (shouldAdd && conditions.dateRange) {
            const bookmarkDate = new Date(node.dateAdded || 0)
            if (conditions.dateRange.start && bookmarkDate < conditions.dateRange.start) {
              shouldAdd = false
            }
            if (conditions.dateRange.end && bookmarkDate > conditions.dateRange.end) {
              shouldAdd = false
            }
          }

          // 如果最终满足所有条件，添加到结果中
          if (shouldAdd) {
            matches.push(node)
          }
        }

        // 递归检查子节点
        if (node.children) {
          node.children.forEach(searchInNode)
        }
      }

      // 开始递归搜索
      tree.forEach(searchInNode)
      
      // 添加调试日志
      console.debug('Matching with conditions:', {
        urlKeywords: conditions.urlKeywords,
        titleKeywords: conditions.titleKeywords,
        dateRange: conditions.dateRange
      })
      console.debug('Found matches:', matches.length)
      
      return matches
    } catch (error) {
      console.error('Error searching bookmarks by tag:', error)
      return []
    }
  }
}

export const bookmarkTagService = new BookmarkTagService()

================
File: src/services/bookmarks/base.ts
================
// src/services/bookmarks/base.ts
import type { BookmarkTreeNode } from "~/types/bookmark"

// 基础书签服务接口
export interface BookmarkBaseService {
  getTree(): Promise<BookmarkTreeNode[]>
  getRecent(count: number): Promise<BookmarkTreeNode[]>
  search(query: string): Promise<BookmarkTreeNode[]>
  getBookmark(id: string): Promise<BookmarkTreeNode>
  removeBookmark(id: string): Promise<void>
  updateBookmark(id: string, changes: { title?: string; url?: string }): Promise<BookmarkTreeNode>
  moveBookmark(id: string, destination: { parentId?: string; index?: number }): Promise<BookmarkTreeNode>
  createBookmark(bookmark: {
    parentId?: string
    index?: number
    title: string
    url?: string
  }): Promise<BookmarkTreeNode>
}

// 基础书签服务实现
export class ChromeBookmarkBaseService implements BookmarkBaseService {

  private getLocalizedBookmarkFolderNames() {
    return {
      others: chrome.i18n.getMessage("bookmarkFolderOthers") || "Other Bookmarks",
      mobile: chrome.i18n.getMessage("bookmarkFolderMobile") || "Mobile Bookmarks"
    }
  }

  async getTree(): Promise<BookmarkTreeNode[]> {
    return new Promise((resolve, reject) => {
      chrome.bookmarks.getTree((results) => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError)
        } else {
          const rootChildren = results[0]?.children || []
          
          if (rootChildren[0]?.children) {
            const bookmarkBar = [...rootChildren[0].children]
            const folderNames = this.getLocalizedBookmarkFolderNames()
            
            // 添加其他书签文件夹
            if (rootChildren[1]) {
              bookmarkBar.push({
                ...rootChildren[1],
                title: folderNames.others
              })
            }
            
            // 添加移动设备书签文件夹
            if (rootChildren[2]) {
              bookmarkBar.push({
                ...rootChildren[2],
                title: folderNames.mobile
              })
            }
            
            resolve(bookmarkBar)
          } else {
            resolve([])
          }
        }
      })
    })
  }

  async getRecent(count: number): Promise<BookmarkTreeNode[]> {
    try {
      // 获取所有书签树
      const tree = await chrome.bookmarks.getTree();
      
      // 扁平化处理,提取所有节点
      const allNodes: BookmarkTreeNode[] = [];
      
      const extractNodes = (nodes: BookmarkTreeNode[]) => {
        for (const node of nodes) {
          // 排除根节点
          if (node.parentId) {
            allNodes.push(node);
          }
          if (node.children) {
            extractNodes(node.children);
          }
        }
      };
      
      extractNodes(tree);
      
      // 按创建时间排序
      return allNodes
        .sort((a, b) => (b.dateAdded || 0) - (a.dateAdded || 0))
        .slice(0, count);
    } catch (error) {
      console.error('Failed to get recent bookmarks:', error);
      return [];
    }
  }

  async search(query: string): Promise<BookmarkTreeNode[]> {
    return new Promise((resolve, reject) => {
      chrome.bookmarks.search(query, (results) => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError)
        } else {
          resolve(results)
        }
      })
    })
  }

  async getBookmark(id: string): Promise<BookmarkTreeNode> {
    const results = await chrome.bookmarks.get(id)
    return results[0]
  }

  async removeBookmark(id: string): Promise<void> {
    return new Promise((resolve, reject) => {
      chrome.bookmarks.remove(id, () => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError)
        } else {
          resolve()
        }
      })
    })
  }

  async updateBookmark(
    id: string,
    changes: { title?: string; url?: string }
  ): Promise<BookmarkTreeNode> {
    return new Promise((resolve, reject) => {
      chrome.bookmarks.update(id, changes, (result) => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError)
        } else {
          resolve(result)
        }
      })
    })
  }

  async moveBookmark(
    id: string,
    destination: { parentId?: string; index?: number }
  ): Promise<BookmarkTreeNode> {
    return new Promise((resolve, reject) => {
      chrome.bookmarks.move(id, destination, (result) => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError)
        } else {
          resolve(result)
        }
      })
    })
  }

  async createBookmark(bookmark: {
    parentId?: string
    index?: number
    title: string
    url?: string
  }): Promise<BookmarkTreeNode> {
    return new Promise((resolve, reject) => {
      chrome.bookmarks.create(bookmark, (result) => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError)
        } else {
          resolve(result)
        }
      })
    })
  }
}

================
File: src/services/bookmarks/search.ts
================
// src/services/bookmarks/search.ts
import { ChromeBookmarkBaseService } from "./base"
import { descriptionStorage } from "../storage/description"
import type { BookmarkTreeNode } from "~/types/bookmark"

export class BookmarkSearchService {
  private bookmarkService: ChromeBookmarkBaseService

  constructor() {
    this.bookmarkService = new ChromeBookmarkBaseService()
  }

  async search(query: string): Promise<BookmarkTreeNode[]> {
    if (!query.trim()) {
      return []
    }

    try {
      // 并行执行搜索
      const [bookmarkResults, descriptionMatches] = await Promise.all([
        this.searchBookmarks(query),
        this.searchDescriptions(query)
      ])

      // 合并结果并去重
      return this.mergeAndDedupResults(bookmarkResults, descriptionMatches)
    } catch (error) {
      console.error('Search error:', error)
      throw new Error('搜索失败，请重试')
    }
  }

  private async searchBookmarks(query: string): Promise<BookmarkTreeNode[]> {
    try {
      return await this.bookmarkService.search(query)
    } catch (error) {
      console.error('Bookmark search error:', error)
      return []
    }
  }

  private async searchDescriptions(query: string): Promise<BookmarkTreeNode[]> {
    try {
      const descriptionMatches = await descriptionStorage.searchDescriptions(query)
      const bookmarks = await Promise.all(
        descriptionMatches.map(async ({ id }) => {
          try {
            return await this.bookmarkService.getBookmark(id)
          } catch {
            return null
          }
        })
      )
      return bookmarks.filter((b): b is BookmarkTreeNode => b !== null)
    } catch (error) {
      console.error('Description search error:', error)
      return []
    }
  }

  private mergeAndDedupResults(...resultSets: BookmarkTreeNode[][]): BookmarkTreeNode[] {
    const seen = new Set<string>()
    const merged: BookmarkTreeNode[] = []

    for (const results of resultSets) {
      for (const bookmark of results) {
        if (!seen.has(bookmark.id)) {
          seen.add(bookmark.id)
          merged.push(bookmark)
        }
      }
    }

    return merged
  }
}

export const bookmarkSearchService = new BookmarkSearchService()

================
File: src/services/bookmarks/template.ts
================
import type { BookmarkTreeNode } from "~/types/bookmark"
import type { TagTemplate } from "~/types/tag"
import { bookmarkService } from "."
import { tagStorage } from "~/services/storage"

// 添加停用词常量
const STOP_WORDS = new Set([
  // 中文停用词
  "的", "了", "和", "与", "或", "在", "是", "这", "那", "都", "而", "及", "等", "把",
  // 英文停用词
  "the", "a", "an", "and", "or", "in", "on", "at", "to", "for", "of", "with",
  // 通用词
  "com", "www", "http", "https", "html", "php", "asp", "jsp"
])

export class BookmarkTemplateService {
  // 从书签数据中提取关键词，使用 TF-IDF 算法
  private async extractKeywords(): Promise<{
    domains: Map<string, number>,
    titles: Map<string, { count: number; tfidf: number }>
  }> {
    const bookmarks = await bookmarkService.getTree()
    const domains = new Map<string, number>()
    const titles = new Map<string, { count: number; tfidf: number }>()
    const documentFrequency = new Map<string, number>()
    const totalDocuments = this.countBookmarks(bookmarks)
    
    // 第一遍遍历：计算词频和文档频率
    const processNode = (node: BookmarkTreeNode) => {
      if (node.url) {
        try {
          // 处理域名
          const url = new URL(node.url)
          const domain = url.hostname
          domains.set(domain, (domains.get(domain) || 0) + 1)
          
          // 处理标题关键词
          const words = this.tokenizeTitle(node.title)
          const seenWords = new Set<string>()
          
          words.forEach(word => {
            // 更新词频
            const current = titles.get(word) || { count: 0, tfidf: 0 }
            titles.set(word, { ...current, count: current.count + 1 })
            
            // 更新文档频率（每个文档只计算一次）
            if (!seenWords.has(word)) {
              documentFrequency.set(word, (documentFrequency.get(word) || 0) + 1)
              seenWords.add(word)
            }
          })
        } catch (e) {
          console.error('URL parsing error:', e)
        }
      }
      
      if (node.children) {
        node.children.forEach(processNode)
      }
    }
    
    bookmarks.forEach(processNode)
    
    // 计算 TF-IDF 值
    titles.forEach((value, word) => {
      const tf = value.count
      const idf = Math.log(totalDocuments / (documentFrequency.get(word) || 1))
      value.tfidf = tf * idf
    })
    
    return { domains, titles }
  }

  // 分词和过滤
  private tokenizeTitle(title: string): string[] {
    return title
      .toLowerCase()
      .split(/[\s\-_\.,]+/) // 更完善的分词规则
      .filter(word => 
        word.length > 2 && // 过滤短词
        !STOP_WORDS.has(word) && // 过滤停用词
        /^[\w\u4e00-\u9fa5]+$/.test(word) // 只保留字母、数字和中文
      )
  }

  // 计算总书签数
  private countBookmarks(bookmarks: BookmarkTreeNode[]): number {
    let count = 0
    const processNode = (node: BookmarkTreeNode) => {
      if (node.url) count++
      if (node.children) node.children.forEach(processNode)
    }
    bookmarks.forEach(processNode)
    return count
  }

  // 计算模板匹配的书签数量
  private async getMatchCount(conditions: TagTemplate['conditions']): Promise<number> {
    const bookmarks = await bookmarkService.getTree()
    let count = 0
    
    const processNode = (node: BookmarkTreeNode) => {
      if (node.url) {
        let matches = true
        
        // 检查 URL 关键词
        if (conditions.urlKeywords.length > 0) {
          const urlLower = node.url.toLowerCase()
          matches = conditions.urlKeywords.some(keyword => 
            urlLower.includes(keyword.toLowerCase())
          )
        }
        
        // 检查标题关键词
        if (matches && conditions.titleKeywords.length > 0) {
          const titleLower = node.title.toLowerCase()
          matches = conditions.titleKeywords.some(keyword =>
            titleLower.includes(keyword.toLowerCase())
          )
        }
        
        if (matches) count++
      }
      
      if (node.children) {
        node.children.forEach(processNode)
      }
    }
    
    bookmarks.forEach(processNode)
    return count
  }

  // 添加获取现有标签的方法
  private async getExistingTagNames(): Promise<Set<string>> {
    try {
      const existingTags = await tagStorage.getAllTags()
      return new Set(existingTags.map(tag => tag.name.toLowerCase()))
    } catch (error) {
      console.error('Failed to get existing tags:', error)
      return new Set()
    }
  }

  // 修改生成模板的方法
  async generateTemplates(): Promise<TagTemplate[]> {
    const [{ domains, titles }, existingTagNames] = await Promise.all([
      this.extractKeywords(),
      this.getExistingTagNames()
    ])
    
    const templates: TagTemplate[] = []
    
    // 处理域名模板
    const sortedDomains = [...domains.entries()]
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10) // 获取更多候选项，因为要过滤掉已存在的
    
    // 处理标题关键词模板
    const sortedTitles = [...titles.entries()]
      .sort((a, b) => b[1].tfidf - a[1].tfidf)
      .slice(0, 20) // 同样获取更多候选项
    
    // 生成域名模板（添加名称检查）
    for (const [domain, count] of sortedDomains) {
      if (count >= 3) {
        const name = this.getDomainDisplayName(domain)
        // 检查标签名是否已存在
        if (!existingTagNames.has(name.toLowerCase())) {
          const conditions = {
            urlKeywords: [domain],
            titleKeywords: []
          }
          
          const matchCount = await this.getMatchCount(conditions)
          
          templates.push({
            id: domain,
            name,
            description: `包含 ${domain} 的书签 (${matchCount}个)`,
            conditions,
            weight: matchCount
          })
        }
      }
    }
    
    // 生成关键词模板（添加名称检查）
    const keywordGroups = this.groupRelatedKeywords(sortedTitles)
    for (const group of keywordGroups) {
      const keywords = group.map(([word]) => word)
      const name = this.getKeywordGroupName(group)
      
      // 检查标签名是否已存在
      if (!existingTagNames.has(name.toLowerCase())) {
        const conditions = {
          urlKeywords: [],
          titleKeywords: keywords
        }
        
        const matchCount = await this.getMatchCount(conditions)
        if (matchCount >= 2) {
          templates.push({
            id: keywords[0],
            name,
            description: `包含相关关键词的书签 (${matchCount}个)`,
            conditions,
            weight: matchCount
          })
        }
      }
    }
    
    // 按权重排序并返回前8个模板
    return templates
      .sort((a, b) => (b.weight || 0) - (a.weight || 0))
      .slice(0, 8)
  }

  // 优化的域名显示名称处理
  private getDomainDisplayName(domain: string): string {
    return domain
      .replace(/^www\./, '')
      .split('.')
      .slice(0, -1)
      .join('.')
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ')
  }

  // 改进的关键词分组算法
  private groupRelatedKeywords(
    keywords: Array<[string, { count: number; tfidf: number }]>
  ): Array<[string, { count: number; tfidf: number }]>[] {
    const groups: Array<[string, { count: number; tfidf: number }]>[] = []
    const used = new Set<string>()
    
    // 按 TF-IDF 值排序
    const sortedKeywords = keywords.sort((a, b) => b[1].tfidf - a[1].tfidf)
    
    for (const [word, stats] of sortedKeywords) {
      if (used.has(word)) continue
      
      const group: Array<[string, { count: number; tfidf: number }]> = [[word, stats]]
      used.add(word)
      
      // 寻找相似词
      for (const [candidate, candidateStats] of sortedKeywords) {
        if (!used.has(candidate)) {
          const similarity = this.calculateSimilarity(word, candidate)
          if (similarity > 0.7) {
            group.push([candidate, candidateStats])
            used.add(candidate)
          }
        }
      }
      
      if (group.length > 1) {
        groups.push(group)
      }
    }
    
    return groups
  }

  // 改进的相似度计算（Jaro-Winkler 距离）
  private calculateSimilarity(s1: string, s2: string): number {
    const getCommonChars = (str1: string, str2: string, halflen: number): string => {
      const common = []
      const seen = new Set()
      
      for (let i = 0; i < str1.length; i++) {
        const ch = str1[i]
        const start = Math.max(0, i - halflen)
        const end = Math.min(i + halflen + 1, str2.length)
        
        for (let j = start; j < end; j++) {
          if (!seen.has(j) && str2[j] === ch) {
            common.push(ch)
            seen.add(j)
            break
          }
        }
      }
      
      return common.join('')
    }
    
    const len1 = s1.length
    const len2 = s2.length
    if (len1 === 0 || len2 === 0) return 0
    
    const maxDist = Math.floor(Math.max(len1, len2) / 2) - 1
    const common1 = getCommonChars(s1, s2, maxDist)
    const common2 = getCommonChars(s2, s1, maxDist)
    
    if (common1.length !== common2.length) return 0
    if (common1.length === 0) return 0
    
    let transpositions = 0
    for (let i = 0; i < common1.length; i++) {
      if (common1[i] !== common2[i]) transpositions++
    }
    
    const commonLen = common1.length
    const jaroDistance = (
      commonLen / len1 +
      commonLen / len2 +
      (commonLen - transpositions / 2) / commonLen
    ) / 3
    
    return jaroDistance
  }

  // 优化的关键词组显示名称
  private getKeywordGroupName(
    group: Array<[string, { count: number; tfidf: number }]>
  ): string {
    if (group.length === 1) {
      return this.capitalizeWord(group[0][0])
    }
    
    // 按 TF-IDF 值排序，选择最重要的关键词
    const sortedGroup = [...group].sort((a, b) => b[1].tfidf - a[1].tfidf)
    const mainKeyword = sortedGroup[0][0]
    
    if (group.length <= 3) {
      return sortedGroup
        .map(([word]) => this.capitalizeWord(word))
        .join(' / ')
    }
    
    return `${this.capitalizeWord(mainKeyword)} +${group.length - 1}`
  }

  private capitalizeWord(word: string): string {
    return word.charAt(0).toUpperCase() + word.slice(1)
  }
}

export const templateService = new BookmarkTemplateService()

================
File: src/services/bookmarks/keyword.ts
================
// src/services/bookmarks/keyword.ts
export class KeywordSuggestionService {
  // 基于当前输入生成建议
  async suggestFromInput(input: string): Promise<string[]> {
    // 实现建议逻辑
    return []
  }

  // 基于现有书签数据生成建议
  async suggestFromBookmarks(): Promise<string[]> {
    try {
      const bookmarks = await chrome.bookmarks.getTree()
      // 实现提取关键词的逻辑
      return []
    } catch (error) {
      console.error('Failed to generate suggestions:', error)
      return []
    }
  }
}

export const keywordSuggestionService = new KeywordSuggestionService()

================
File: src/services/bookmarks/index.ts
================
// src/services/bookmarks/index.ts
export * from './base'
export * from './pin'
export * from './search'
export * from './tag'

import { ChromeBookmarkBaseService } from './base'
import { bookmarkPinService } from './pin'
import { bookmarkSearchService } from './search'
import { bookmarkTagService } from './tag'

// 导出主服务实例
export const bookmarkService = new ChromeBookmarkBaseService()
export const pinService = bookmarkPinService
export const searchService = bookmarkSearchService
export const tagService = bookmarkTagService

================
File: src/services/bookmarks/pin.ts
================
// src/services/bookmarks/pin.ts
import { ChromeBookmarkBaseService } from "./base"
import { pinStorage } from "../storage/pin"
import type { BookmarkTreeNode } from "~/types/bookmark"

export class BookmarkPinService {
  private bookmarkService: ChromeBookmarkBaseService

  constructor() {
    this.bookmarkService = new ChromeBookmarkBaseService()
  }

  async initialize(): Promise<void> {
    await pinStorage.initialize()
  }

  // 书签固定相关方法
  async pinBookmark(id: string): Promise<void> {
    await pinStorage.addPinnedBookmark(id)
  }

  async unpinBookmark(id: string): Promise<void> {
    await pinStorage.removePinnedBookmark(id)
  }

  async isBookmarkPinned(id: string): Promise<boolean> {
    const pinnedIds = await pinStorage.getPinnedBookmarkIds()
    return pinnedIds.includes(id)
  }

  async getPinnedBookmarkIds(): Promise<string[]> {
    return await pinStorage.getPinnedBookmarkIds()
  }

  // 文件夹固定相关方法
  async pinFolder(id: string): Promise<void> {
    await pinStorage.addPinnedFolder(id)
  }

  async unpinFolder(id: string): Promise<void> {
    await pinStorage.removePinnedFolder(id)
  }

  async isFolderPinned(id: string): Promise<boolean> {
    const pinnedFolderIds = await pinStorage.getPinnedFolderIds()
    return pinnedFolderIds.includes(id)
  }

  async getPinnedFolderIds(): Promise<string[]> {
    return await pinStorage.getPinnedFolderIds()
  }

  // 获取固定的书签和文件夹具体内容
  async getPinnedBookmarks(): Promise<BookmarkTreeNode[]> {
    const pinnedIds = await pinStorage.getPinnedBookmarkIds()
    const pinnedBookmarks = await Promise.all(
      pinnedIds.map(async id => {
        try {
          const bookmark = await this.bookmarkService.getBookmark(id)
          return bookmark.url ? bookmark : null // 只返回有URL的书签
        } catch (error) {
          console.error(`Failed to load pinned bookmark ${id}:`, error)
          return null
        }
      })
    )
    
    return pinnedBookmarks.filter((bookmark): bookmark is BookmarkTreeNode => 
      bookmark !== null
    )
  }

  async getPinnedFolders(): Promise<BookmarkTreeNode[]> {
    const pinnedFolderIds = await pinStorage.getPinnedFolderIds()
    const folders = await Promise.all(
      pinnedFolderIds.map(async id => {
        try {
          const [folder] = await chrome.bookmarks.getSubTree(id)
          return folder.url ? null : folder // 只返回没有URL的文件夹
        } catch (error) {
          console.error(`Failed to load pinned folder ${id}:`, error)
          return null
        }
      })
    )
    
    return folders.filter((folder): folder is BookmarkTreeNode => 
      folder !== null
    )
  }

  // 清理无效的固定项
  async cleanupInvalidPins(): Promise<void> {
    const [pinnedBookmarkIds, pinnedFolderIds] = await Promise.all([
      this.getPinnedBookmarkIds(),
      this.getPinnedFolderIds()
    ])

    const validBookmarks = await Promise.all(
      pinnedBookmarkIds.map(async id => {
        try {
          await this.bookmarkService.getBookmark(id)
          return true
        } catch {
          return false
        }
      })
    )

    const validFolders = await Promise.all(
      pinnedFolderIds.map(async id => {
        try {
          await this.bookmarkService.getBookmark(id)
          return true
        } catch {
          return false
        }
      })
    )

    // 移除无效的书签
    const invalidBookmarkIds = pinnedBookmarkIds.filter((_, index) => !validBookmarks[index])
    for (const id of invalidBookmarkIds) {
      await this.unpinBookmark(id)
    }

    // 移除无效的文件夹
    const invalidFolderIds = pinnedFolderIds.filter((_, index) => !validFolders[index])
    for (const id of invalidFolderIds) {
      await this.unpinFolder(id)
    }
  }
}

// 导出单例实例
export const bookmarkPinService = new BookmarkPinService()
